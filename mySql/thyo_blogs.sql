/*
 Navicat Premium Data Transfer

 Source Server         : 121.5.79.74
 Source Server Type    : MySQL
 Source Server Version : 50562
 Source Host           : 121.5.79.74:3306
 Source Schema         : thyo_blogs

 Target Server Type    : MySQL
 Target Server Version : 50562
 File Encoding         : 65001

 Date: 06/03/2023 14:25:32
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `user_id` int(11) NULL DEFAULT NULL COMMENT '创建用户',
  `creation_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `view_num` int(11) NOT NULL DEFAULT 0 COMMENT '查看人数',
  `brief` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '简介',
  `class_one_id` int(11) NULL DEFAULT NULL COMMENT '一级id',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '文章内容',
  `class_two_id` int(11) NULL DEFAULT NULL COMMENT '二级id',
  `preview` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '展示图片',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 227 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (24, '什么是闭包？', 1, '2023-02-08 14:08:56', 0, '写这个文章也是为了回顾下闭包的只是点，其实许多前端对闭包都有点一知半解，包括我自己也是。', 21, '<div><span>闭包函数：声明在一个函数中的函数，叫做闭包函数。</span></div><p><divcourier new\',=\"\" monospace;font-weight:=\"\" normal;font-size:=\"\" 14px;line-height:=\"\" 19px;white-space:=\"\" pre;\"=\"\"></divcourier></p><div><span>内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。其实闭包在我看来就是变量作用域的。</span></div><div><span><br></span></div><div><span><br></span></div><div><span><br></span></div><div><p>优点：</p><ul><li>避免全局变量的污染</li><li>能够读取函数内部的变量</li><li>可以在内存中维护一个变量</li></ul><p>缺点：</p><ul><li>闭包会常驻内存，会增大内存使用量，导致一定程度上的内存泄露。</li><li>在游览器中因为回收机制无法回收闭包的函数以及闭包函数中储存的数据，会使游览器占用更多的性能开销</li></ul></div><div><span><br></span></div><div><span><br></span></div><div><pre><code>function f1() {\n    let n = 0;\n    return function f2() {\n        console.log(n += 1);\n    }\n}\nvar result = f1();\nresult() //?\nresult() //?</code></pre><p><br></p></div>', 23, 'http://image.thyo.xyz/img/f4239328-b716-7242-c78b-505cdcc25800');
INSERT INTO `article` VALUES (25, '防抖函数实现', 1, '2023-02-08 15:21:16', 2, '防抖函数是一种常用的 JavaScript 技巧，它可以在指定的时间内忽略重复的触发，从而减少不必要的计算或请求。', 21, '<pre><code>function debounce(fn, wait) {\n  let timeout;\n  return function() {\n    clearTimeout(timeout);\n    timeout = setTimeout(() =&gt; {\n      fn.apply(this, arguments);\n    }, wait);\n  };\n}</code></pre><p>使用方法</p><pre><code>const myFn = debounce(() =&gt; {\n  console.log(\'Hello World!\');\n}, 1000);\n\nwindow.addEventListener(\'resize\', myFn);</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (26, '节流函数实现', 1, '2023-02-08 15:25:55', 16, '如果持续触发事件，每隔一段时间只执行一次函数。', 21, '<pre><code>var throttle = function (func, delay) {\n        var prev = Date.now()\n        return function () {\n            var context = this;\n            var args = arguments;\n            var now = Date.now();\n            if (now - prev &gt;= delay) {\n                func.apply(context, args);\n                prev = Date.now();\n            }\n        }\n    }</code></pre><p>使用方法</p><pre><code>window.onload = function() {\n    var bodyEl = document.getElementsByTagName(\"body\")[0]\n}\n\nvar count = 0;\nwindow.onmousemove = throttle(eventHandler, 1000);\n\nfunction eventHandler(e) {\n    var containerEl = document.getElementById(\"container\");\n    containerEl.innerHTML = \"正在滑动: \" + count;\n    count++;\n}</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (27, 'H5 的新特性有哪些？C3 的新特性有哪些？', 1, '2023-02-09 10:57:19', 1, 'H5 的新特性有哪些？C3 的新特性有哪些？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><b>H5 新特性\n</b></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1. 拖拽释放(Drap and drop) API ondrop\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">拖放是一种常见的特性，即抓取对象以后拖到另一个位置。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2. 自定义属性 data-id\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3. 语义化更好的内容标签(header,nav,footer ,aside, article, section)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4. 音频 ,视频(audio, video) 如果浏览器不支持自动播放怎么办?在属性中添加 autoplay\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5. 画布 Canvas\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1） getContext() 方法返回一个用于在画布上绘图的环境。Canvas.getContext(contextID)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">参数 contextID 指定了您想要在画布上绘制的类型。当前唯一的合法值是 “2d”，它指定了\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">二维绘图，并且导致这个方法返回一个环境对象，该对象导出一个二维绘图 API。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2） cxt.stroke() 如果没有这一步 线条是不会显示在画布上的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3） canvas 和 image 在处理图片的时候有什么区别?\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">image 是通过对象的形式描述图片的,canvas 通过专门的 API 将图片绘制在画布上.\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">6. 地理(Geolocation) API\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">7. 本地离线存储 localStorage 长期存储数据 浏览器关闭后数据不丢失\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">8. sessionStorage 的数据在浏览器关闭后自动删除\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">9. 表单控件 calendar , date , time , email , url , search , tel , file , number\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">10. 新的技术 webworker, websocket , Geolocation\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><p><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><b>CSS3 新特性\n</b></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></p><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1. 颜色: 新增 RGBA , HSLA 模式\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2. 文字阴影(text-shadow)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3. 边框: 圆角(border-radius) 边框阴影 : box-shadow\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4. 盒子模型: box-sizing\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5. 背景:background-size background-origin background-clip\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">6. 渐变: linear-gradient , radial-gradient\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">7. 过渡 : transition 可实现动画\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">8. 自定义动画 animate @keyfrom\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">9. 媒体查询 多栏布局 @media screen and (width:800px) {…}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">10. border-image\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">11. 2D 转换;transform: translate(x,y) rotate(x,y) skew(x,y) scale(x,y)</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 21, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (28, 'Localstorage 和 sessionStorage 和 cookie 的区别', 1, '2023-02-09 10:58:58', 0, 'cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间\n来回传递，而 sessionStorage 和 localStorage 不会自动把数据发送给服务器，仅在本地保存。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">共同点：都是保存在浏览器端、且同源的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">区别：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器间\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">来回传递，而 sessionStorage 和 localStorage 不会自动把数据发送给服务器，仅在本地保存。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带 cookie、\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">所以 cookie 只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">储大小的限制，但比 cookie 大得多，可以达到 5M 或更大\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的 cookie 过期时\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">间之前有效，即使窗口关闭或浏览器关闭\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4、作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">localstorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5、web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">6、web Storage 的 api 接口使用更方便</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 21, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (29, 'H5 的浏览器存储有哪些？', 1, '2023-02-09 11:00:41', 0, '浏览器存储\n浏览器存储主要包括一下几个部分\n1. cookie\n2. localStorage\n3. sessionStorage\n4. indexDB\n5. websql\n6. window 变量\n7. flash cookie', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">浏览器存储\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:7.92pt;font-family:等线;color:rgb(73,73,73);\">浏览器存储主要包括一下几个部分\n</spanyes\';font-size:7.92pt;font-family:等线;color:rgb(73,73,73);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1. cookie\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2. localStorage\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3. sessionStorage\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4. indexDB\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5. websql\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">6. window 变量\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">7. flash cookie\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、cookie\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">这个存储用了很久了，而且也是以前大多网站十分喜欢的存储站点。但是也很容易被清除。同\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">时 cookie 会在每一次通信过程中传向服务端。同时 cookie 有一个很好的地方就是，它本身有\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">一个过期时间属性，可以用来标注一个变量的有效期。而 cookie 一旦过期就会被自动删除掉。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、localStorage、sessionStorage\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">- localStorage: 持久存储，只要用户不主动删除就会一直存在。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">- sessionStorage：面向 session 的浏览器存储，因此只存在于一个页面的生命周期内，关闭即\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">清除两者均采用键值对的形式存储数据\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、indexedDB\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">内嵌在浏览器端的非关系型数据库，数据以键值对的形式存储，兼容性良好。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">indexDB 直接操作的存储对象是 ObjectStore，这有点类似其他数据库中 table 概念。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4、websql\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">内嵌在浏览器的关系型数据库，前端可以像在使用 mysql、Oracle 一样的写 sql 语句，并存储信\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">息。兼容性良好。存储后可在浏览器 resource 中查看。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5、window 变量\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">生命周期有限，一般大家也不会去使用。但是对于全局变量的临时存储来说，还是一个不可多\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">得的好地方。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">6、flash cookie\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">flash cookie 现在用的地方比较多</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 21, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (30, '如何使一个盒子水平垂直居中？', 1, '2023-02-09 11:02:21', 2, '如何使一个盒子水平垂直居中？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1.absolute + transform：绝对定位加+转换</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><pre><code>&lt;div class=\"parent\"&gt; \n&lt;div class=\"child\"&gt;Demo&lt;/div&gt; \n&lt;/div&gt; \n&lt;style&gt; \nparent { \nposition：relative; \n} \nchild { \nposition： absolute; \nleft： 50%; \ntop：50%; \n} \n&lt;/style&gt;</code></pre><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">2.inline-block + text-align + table-cell + vertical-align（单元格方式）</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><pre><code>&lt;div class=\"parent\"&gt; \n&lt;div class=\"child\"&gt;Demo&lt;/div&gt; \n&lt;/div&gt; \n&lt;style&gt; \n.parent { \ntext-align：center; \ndisplay：table-cell; \nvertical-align：middle; \n}\n.child { \ndisplay： inline-block; \n} \n&lt;/style&gt;</code></pre><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">3.flex + justify-content + align-items（弹性模型）</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>&lt;div class=\"parent\"&gt; \n&lt;div class=\"child\"&gt;Demo&lt;/div&gt; \n&lt;/div&gt;\n&lt;style&gt; \n.parent { \ndisplay： flex; \njustify-content： center; /* 水平居中 */ \nalign-items：center; /*垂直居中*/ \n} \n&lt;style&gt;</code></pre></spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (31, '如何垂直居中一个 img?', 1, '2023-02-09 11:05:43', 0, '#container //<img>的容器设置如下\n{ \ndisplay:table-cell; \ntext-align:center; \nvertical-align:middle; \n}', 21, '<div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">#container //&lt;img&gt;的容器设置如下\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">{ \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">display:table-cell; \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">text-align:center; \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">vertical-align:middle; \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">}&nbsp;</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (33, 'Css 的盒模型？', 1, '2023-02-09 11:14:12', 2, '盒子模型（Box Modle）可以用来对元素进行布局，包括内边距，边框，外边距，和实际内容\n这几个部分。\n盒子模型分为两种 第一种是 W3c 标准的盒子模型（标准盒模型） 、第二种 IE 标准的盒子模型\n（怪异盒模型）', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">盒子模型（Box Modle）可以用来对元素进行布局，包括内边距，边框，外边距，和实际内容\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">这几个部分。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">盒子模型分为两种 第一种是 W3c 标准的盒子模型（标准盒模型） 、第二种 IE 标准的盒子模型</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">（怪异盒模型）</span></div><div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">一、标准盒模型与怪异盒模型的表现效果的区别之处：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、标准盒模型中 width 指的是内容区域 content 的宽度；height 指的是内容区域 content 的高\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">度。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">标准盒模型下盒子的大小 = content + border + padding + margin</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、怪异盒模型中的 width 指的是内容、边框、内边距总的宽度（content + border +\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">padding）；height 指的是内容、边框、内边距总的高度\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">怪异盒模型下盒子的大小=width（content + border + padding） + margin</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">除此之外，我们还可以通过属性 box-sizing 来设置盒子模型的解析模式\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">可以为 box-sizing 赋两个值：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">content-box： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">默认值，border 和 padding 不算到 width 范围内，可以理解为是 W3c 的标准模\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">型(default)。总宽=width+padding+border+margin\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">border-box：border 和 padding 划归到 width 范围内，可以理解为是 IE 的怪异盒模型，总宽\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">=width+margin</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><br></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><br></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><br></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (34, '什么是渐进增强和优雅降级?它们有什么不同？', 1, '2023-02-09 11:15:02', 1, '优雅降级和渐进增强印象中是随着 css3 流出来的一个概念。由于低级浏览器不支持\ncss3，但 css3 的效果又太优秀不忍放弃，所以在高级浏览中使用 css3 而低级浏览器只保证', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">优雅降级和渐进增强印象中是随着 css3 流出来的一个概念。由于低级浏览器不支持\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">css3，但 css3 的效果又太优秀不忍放弃，所以在高级浏览中使用 css3 而低级浏览器只保证</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">最基本的功能。关键的区别 是他们所侧重的内容，以及这种不同造成的工作流程的差异。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">举个例子：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">a{ \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">display：block；\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">width：200px；\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">height： </spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">100px；\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">background：aquamarine；\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">/*我就是要用这个新 css 属性*/\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">transition：all 1s ease 0s；\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">/*可是发现了一些低版本浏览器不支持怎么吧*/\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">/*往下兼容*/\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">-webkit-transition：all 1s ease 0s；\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">-moz-transition：all 1s ease 0s；\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">-o-transition： </spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">all 1s ease 0s；\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">/*那么通常这样考虑的和这样的侧重点出发的 css 就是优雅降级*/\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">}\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">a：hover{ \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">height：200px；\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">}\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">/ *那如果我们的产品要求我们要重低版本的浏览器兼容开始*/ \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">a{ \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">/*优先考虑低版本的*/ \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">-webkit-transition：all 1s ease 0s；\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">-moz-transition：all 1s ease 0s；\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">-o-transition： </spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">all 1s ease 0s；\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">/*高版本的就肯定是渐进渐强*/ \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">transition：all 1s ease 0s；\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">}\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">“渐进增强”观点则认为应关注于内容本身</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (35, '哪些是块级元素那些是行内元素，各有什么特点', 1, '2023-02-09 11:15:53', 0, '行内元素: a、span、b、img、strong、input、select、lable、em、button、textarea 、\nselecting\n块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote、form', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">行内元素: a、span、b、img、strong、input、select、lable、em、button、textarea 、\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">selecting\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">块级元素：div、ul、li、dl、dt、dd、p、h1-h6、blockquote、form</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">行内、块状元素区别：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(1).块级元素会独占一行，其宽度自动填满其父元素宽度行内元素不会独占一行，相邻的行内元\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">素会排列在同一行里，知道一行排不下，才会换行，其宽度随元素的内容而变化</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(2). 一般情况下，块级元素可以设置 width,height 属性，行内元素设置 width, height 无效\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(注意：块级元素即使设置了宽度，仍然是独占一行的)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(3).块级元素可以设置 margin 和 padding. 行内元素的水平方向的 padding-left,padding</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">right,margin-left,margin-right 都产生边距效果，但是竖直方向的 padding-top,padding</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">bottom,margin-top,margin-bottom 都不会产生边距效果。（水平方向有效，竖直方向无效）</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (36, 'Css 选择器有哪些?哪些属性可以继承?', 1, '2023-02-09 11:16:56', 0, 'Css 选择器有哪些?哪些属性可以继承?一，css 选择器：\n1.id 选择器（ # myid）\n2.类选择器（.myclassname）\n3.标签选择器（div, h1, p）\n4.相邻选择器（h1 + p）\n5.子选择器（ul > li）\n6.后代选择器（li a）\n7.通配符选择器（ * ）\n8.属性选择器（a[rel = \"external\"]）\n9.伪类选择器（a:hover, li:nth-child）', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">一，css 选择器：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1.id 选择器（ </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"># myid）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2.类选择器（.myclassname）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3.标签选择器（div, h1, p）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4.相邻选择器（h1 + p）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5.子选择器（ul &gt; li）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">6.后代选择器（li a）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">7.通配符选择器（ </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">* ）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">8.属性选择器（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">a[rel = \"external\"]）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">9.伪类选择器（a:hover, li:nth-child）</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">二，继承问题：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">可继承的样式： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">font-size font-family color, UL LI DL DD DT;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">不可继承的样式：border padding margin width height ;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (37, '说说你对语义化的理解？列举 5 个语义化的标签？', 1, '2023-02-09 11:17:40', 0, '去掉或样式丢失的时候能让页面呈现清晰的结构：html 本身是没有表现的，我们看到例如\n<h1>是粗体，字体大小 2em，加粗；<strong>是加粗的，不要认为这是 html 的表现，这些其\n实 html 默认的 css 样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语\n义化的 HTML 结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达\nhtml 的语义，可以说浏览器的默认样式和语义化的 HTML 结构是不可分割的。\n2、屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、去掉或样式丢失的时候能让页面呈现清晰的结构：html 本身是没有表现的，我们看到例如\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;h1&gt;是粗体，字体大小 2em，加粗；&lt;strong&gt;是加粗的，不要认为这是 html 的表现，这些其\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">实 html 默认的 css 样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">义化的 HTML 结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">html 的语义，可以说浏览器的默认样式和语义化的 HTML 结构是不可分割的。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">CSS 的支持较弱）。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4、有利于 SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">签来确定上下文和各个关键字的权重。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5、便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循 W3C 标准的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">团队都遵循这个标准，可以减少差异化。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">常见的语义化标签\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;header&gt;元素描述了文档的头部区域标签定义导航链接的部分。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;section&gt; 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">分。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;article&gt; 标签定义独立的内容。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;aside&gt; 标签定义页面主区域内容之外的内容（比如侧边栏）。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;footer&gt; 元素描述了文档的底部区域</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (38, '列举 5 个以上的 H5 事件？', 1, '2023-02-09 11:18:12', 1, '列举 5 个以上的 H5 事件？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onblur：当失去焦点时运行脚本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onchange：当元素改变时运行脚本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onclick：当单击鼠标时运行脚本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ondrop：当被拖动元素正在被拖放时运行脚本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onended：当媒体已抵达结尾时运行脚本</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onerror：当在元素加载期间发生错误时运行脚本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onfocus：当获得焦点时运行脚本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">oninput：当元素获得用户输入时运行脚本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onkeydown：当按下按键时运行脚本（还没松开时就触发）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onkeypress：当按下并松开按键时运行脚本（必须经历按下、松开这一过程才触发）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onkeyup：当松开按键时运行脚本（松开时即触发）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onload：当加载时运行脚本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onmousedown： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当按下鼠标按钮时运行脚本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onmousemove：当鼠标指针移动时运行脚本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onmouseout：当鼠标指针移出元素时运行脚本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onmouseover：当鼠标指针移至元素之上时运行脚本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onmouseup：当松开鼠标按钮时运行脚本</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 21, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (39, 'Css 单位中 px、em 和 rem 的区别？', 1, '2023-02-09 11:19:12', 0, '）px 像素（Pixel）。绝对单位。像素 px 是相对于显示器屏幕分辨率而言的，是一\n个虚拟长度单位，是计算机系统的数字化图像长度单位。\n2）em 是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字\n体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小，因\n此并不是一个固定的值。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">答、 1）px 像素（Pixel）。绝对单位。像素 px 是相对于显示器屏幕分辨率而言的，是一\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">个虚拟长度单位，是计算机系统的数字化图像长度单位。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）em 是相对长度单位，相对于当前对象内文本的字体尺寸。如当前对行内文本的字\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。它会继承父级元素的字体大小，因\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">此并不是一个固定的值。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）rem 是 CSS3 新增的一个相对单位（root em，根 em），使用 rem 为元素设定字\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">体大小时，仍然是相对大小，但相对的只是 HTML 根元素。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4）区别：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">IE 无法调整那些使用 px 作为单位的字体大小，而 em 和 rem 可以缩放，rem \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">反应。目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem。&nbsp;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (40, 'rem 适配方法如何计算 HTML 跟字号及适配方案', 1, '2023-02-09 11:20:01', 1, ' 手淘方案\n• 1、拿到设计稿除以 10，得到 font-size 基准值\n• 2、引入 flexible\n• 3、不要设置 meta 的 viewport 缩放值\n• 4、设计稿 px/ font-size 基准值，即可换算为 rem\n• 优：通过动态根 font-size、viewpor、dpr 来做适配，无兼容性问题，适配精准。\n• 劣：需要根据设计稿进行基准值换算，在不使用 sublime text 编辑器插件开发时，单位\n计算复杂', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">通用方案\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、设置根 font-size：625%（或其它自定的值，但换算规则 1rem 不能小于 12px）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、通过媒体查询分别设置每个屏幕的根 font-size\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、css 直接除以 2 再除以 100 即可换算为 rem。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">优：有一定适用性，换算也较为简单。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">劣：有兼容性的坑，对不同手机适配不是非常精准；需要设置多个媒体查询来适应不\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">同手机，单某款手机尺寸不在设置范围之内，会导致无法适配。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">网易方案：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、拿到设计稿除以 100，得到宽度 rem 值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、通过给 html 的 style 设置 font-size，把 1 里面得到的宽度 rem 值代入\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">x document.documentElement.style.fontSize =\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">document.documentElement.clientWidth / x + </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">‘px‘</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、设计稿 px/100 即可换算为 rem\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">优：通过动态根 font-size 来做适配，基本无兼容性问题，适配较为精准，换算简便。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">劣：无 viewport 缩放，且针对 iPhone 的 Retina 屏没有做适配，导致对一些手机的适配\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">不是很到位。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:12pt;font-family:宋体;color:rgb(0,0,0);\"> </spanyes\';font-size:12pt;font-family:宋体;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">手淘方案\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、拿到设计稿除以 10，得到 font-size 基准值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、引入 flexible\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、不要设置 meta 的 viewport 缩放值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4、设计稿 px/ font-size 基准值，即可换算为 rem\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">优：通过动态根 font-size、viewpor、dpr 来做适配，无兼容性问题，适配精准。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">劣：需要根据设计稿进行基准值换算，在不使用 sublime text 编辑器插件开发时，单位\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">计算复杂</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 21, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (41, 'Css 中 link 和@import 的区别？', 1, '2023-02-09 11:20:32', 1, '适用范围不同 @import 可以在网页页面中使用，也可以在 css 文件中使用，用来将多个 css\n文件引入到一个 css 文件中；而 link 只能将 css 文件引入到网页页面中。\n功能范围不同 link 属于 XHTML 标签，而@import 是 CSS 提供的一种方式，link 标签除了可\n以加载 CSS 外，还可以定义 RSS，定义 rel 连接属性等，@import 就只能加载 CSS。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">适用范围不同 @import 可以在网页页面中使用，也可以在 css 文件中使用，用来将多个 css\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">文件引入到一个 css 文件中；而 link 只能将 css 文件引入到网页页面中。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">功能范围不同 link 属于 XHTML 标签，而@import 是 CSS 提供的一种方式，link 标签除了可\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">以加载 CSS 外，还可以定义 RSS，定义 rel 连接属性等，@import 就只能加载 CSS。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">加载顺序不同 当一个页面被加载的时候，link 引用的 CSS 会同时被加载，而@import 引用的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">CSS 会等到页面全部被下载完再被加载。所以有时候浏览@import 加载 CSS 的页面时开始会没\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">有样式（就是闪烁），网速慢的时候还挺明显。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">兼容性 由于@import 是 css2.1 提出的，所以老的浏览器不支持，@import 只有在 IE5 以上的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">才能识别，而 link 标签无此问题。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">控制样式时的差别 使用 link 方式可以让用户切换 CSS 样式.现代浏览器如 Firefox,Opera,Safari\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">都支持 rel=”alternate stylesheet”属性(即可在浏览器上选择不同的风格),当然你还可以使用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Javascript 使得 IE 也支持用户更换样式。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">权重区别 link 引入的样式权重大于@import 引入的样式。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (42, 'Display：none 与 visibility：hidden 的区别？', 1, '2023-02-09 11:21:14', 1, '适用范围不同：@import 可以在网页页面中使用，也可以在 css 文件中使用，用来将多个 CSS\n文件引入到一个 CSS 文件中；而 link 只能将 CSS 文件引入到网页页面中。\n功能范围不同：link 属于 XHTML 标签，而@import 是 CSS 提供的一种方式', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">适用范围不同：@import 可以在网页页面中使用，也可以在 css 文件中使用，用来将多个 CSS\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">文件引入到一个 CSS 文件中；而 link 只能将 CSS 文件引入到网页页面中。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">功能范围不同：link 属于 XHTML 标签，而@import 是 CSS 提供的一种方式，link\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">标签除了可以加载 CSS 外，还可以定义 RSS,定义 rel 连接属性等，@import 就只能加载 CSS\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">加载顺序不同：当一个页面被加载的时候，Link 引用的 CSS 会同时被加载，而@import 引用的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">CSS 会等到页面全部被下载完再被加载，所以有时候浏览@import 加载 CSS 的页面时开始会没\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">有样式（就是闪烁），这种是在网速慢的时候才会看得出来\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">兼容性差别：由于@import 是 CSS2.1 提出的，所以老的浏览器不支持，而@import 只有在 IE5\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">以上的才能识别，而 link 标签无此问题\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">控制样式时差别：使用 Link 方式可以让用户切换 CSS 样式</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (43, 'Position 的值有哪些，分别有哪些作用？', 1, '2023-02-09 11:21:55', 1, 'static：默认值\n不脱离文档流，top，right，bottom，left 等属性不生效。\n绝对定位：absolute\n绝对定位的关键是找对参照物，要成为绝对定位元素的参照物必须满足以下两个条件：', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">static：默认值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">不脱离文档流，top，right，bottom，left 等属性不生效。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">绝对定位：absolute\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">绝对定位的关键是找对参照物，要成为绝对定位元素的参照物必须满足以下两个条件：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1.参照物和绝对定位元素必须是包含与被包含关系；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2.该参照物必须具有定位属性；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">如果找不到满足以上两个条件的父包含块，那么相对于浏览器窗口进行定位。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">注：设置了 position:absolute;属性后，元素会脱离正常文档流，不在占据空间；左右 margin 为\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">auto 将会失效；我们通过 left、top、bottom、right 来决定元素位置。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">相对定位：relative\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">参照物：元素偏移前位置\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">注：设置了相对定位，左右 margin 为 auto 仍然有效、并且不会脱离文档流。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">固定定位：fixed\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">参照物：浏览器窗口；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">注：固定定位会脱离文档流；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当绝对定位和固定定位参照物都是浏览器窗口时的区别： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当出现滚动条时，固定定位的元素不\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">会跟随滚动条滚动，绝对定位会跟随滚动条滚动。&nbsp;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (44, '为什么会出现浮动？浮动元素会引起什么问题？如何 清除浮动？', 1, '2023-02-09 11:23:00', 0, '浮动定位将元素排除在普通流之外，即元素讲脱离文档流，不占据空间。浮动元素碰到包含它\n的边框或者浮动元素的边框停留。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">浮动定位将元素排除在普通流之外，即元素讲脱离文档流，不占据空间。浮动元素碰到包含它\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的边框或者浮动元素的边框停留。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">为什么需要清除浮动\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）父元素的高度无法被撑开，影响与父元素同级的元素；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）与浮动元素同级的非浮动元素（内联元素）会跟随其后；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构解决\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">清除浮动的方式：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）使用 CSS 中的 clear:both;（放一个空的 div，并设置上述 css）,属性来清除元素的浮动可\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">解决 2、3 问题\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）对于问题 1，添加如下样式，给父元素添加 clearfix 样\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">式：.clearfix:after{content: \".\";display: block;height: 0;clear: both;visibility: hidden;}.clearfix{display:\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">inline-block;} /* for IE/Mac */\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）给父级元素设置双伪元素；</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><span style=\"background-color: rgb(241, 241, 241); font-family: couriernew, courier, monospace; font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">&lt;div class=\"container clearfix\"&gt;</span></div><pre><code> &lt;div class=\"wrap\"&gt;aaa&lt;/div&gt;\n&lt;/div&gt;\n.clearfix:after{\n content:\"\"; /*设置内容为空*/\n height:0; /*高度为 0*/\n line-height:0; /*行高为 0*/\n display:block; /*将文本转为块级元素*/\n visibility:hidden; /*将元素隐藏*/\n clear:both; /*清除浮动*/\n}\n.clearfix{\n zoom:1; /*为了兼容 IE*/\n}</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">4）给父级元素设置 overflow：hidden；或 overflow：auto；本质是构建一个 BFC。</span></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (45, '简述弹性盒子 flex 布局及 rem 布局？', 1, '2023-02-09 11:25:36', 3, 'rem 是 CSS3 新增的一个相对单位，相对于根节点(html)字体大小的值，r 就是 root\nhtml{font-size:10px} 则 2rem=20px\n通过它就可以做到只修改根元素的大小，就能成比例地调整所有的字体大小，只依赖 html 字体\n', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">rem 是 CSS3 新增的一个相对单位，相对于根节点(html)字体大小的值，r 就是 root\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">html{font-size:10px} <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">则 2rem=20px\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">通过它就可以做到只修改根元素的大小，就能成比例地调整所有的字体大小，只依赖 html 字体\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的大小。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">适配方案步骤：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、首先动态计算 html 的 font-size\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、将所有的 px 换算成 rem(计算过程请看下面代码和注释（注意：rem 的换算是根据设计图稿\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的像素计算的，下面的计算只是动态计算 html 的 font-size 大小），请看下面的注意事项</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>&lt;meta name=\"viewport\" content=\"width=device-width,user-scalable=no\"/&gt;\n&lt;style&gt;\n body{\n margin: 0;\n }\n div{\n /*width: 80px;*/\n height: 100px;\n width: 4rem;\n height: 4rem;\n /*1rem=20; nrem=80; n=80/rem; n=80/20; n=4*/\n background: green;\n float: left;\n }\n&lt;style&gt;\n&lt;body&gt;\n &lt;div&gt;1&lt;/div&gt;\n &lt;div&gt;3&lt;/div&gt;\n &lt;div&gt;4&lt;/div&gt;\n&lt;/body&gt;\n&lt;script&gt;\n (function(){\n var html=document.documentElement;\n var width=html.getBoundingClientRect().width; //获取屏幕宽度（设备独立像素）， 如\niPhone6 为 414\n html.style.fontSize=width/16+\'px\'; //html font-size = 20px\n //iphone5 下 1rem=20 这里之所以除以 16，是因为要把宽度分成 16 份，这个数并没\n有固定，一般选 15，16，以 ipone5 为准是 16，因为一除可以得到整数 20，好计算。 \n })();\n&lt;/script&gt;</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">注意：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、必需动态的去设置 html 的大小，才能适配\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、根据页面的宽度除以一个系数，把算出的这个值赋给 html 的 font-size 属性，rem 换算值是\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">根据 psd 设计图的宽度/系数的 rem 系数。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">以 640px 设计稿和 750px 的视觉稿，网易这样处理的：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>var width = document.documentElement.clientWidth; // 屏幕的布局视口宽度\nvar rem = width / 7.5; // 750px 设计稿将布局视口分为 7.5 份\nvar rem = width / 6.4; // 640px 设计稿将布局视口分为 6.4 份</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">这样不管是 750px 设计稿还是 640px 设计稿，1rem 等于设计稿上的 100px。故 px 转换 rem\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">时：1rem = 1px * 0.01;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在 750px 设计稿上：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>设计稿上 75px 对应 0.75rem, 距离占设计稿的 10%；\n在 ipone6 上：\nwidth = document.documentElement.clientWidth = 375px；\n1rem = 375px / 7.5 = 50px;\n0.75rem = 37.5px; (37.5/375=10%；占屏幕 10%)\n在 ipone5 上：\nwidth = document.documentElement.clientWidth = 320px；\nrem = 320px / 7.5 = 42.667px;\n0.75rem = 32px; (32/320=10%；占屏幕 10%)</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">故对于设计稿上任何一个尺寸换成 rem 后，在任何屏下对应的尺寸占屏幕宽度的百分比相同。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">故这种布局可以百分比还原设计图。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）为什么要除一个数字，原因是：一个页面里，不可能全都是整屏的元素，肯定有一行中放多\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">个元素。所以就把一行分成 n 份\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）不除一个数字的话，那 1 个 rem 就是屏幕的宽度，这个值太大，如果一个元素的宽度比它\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">小的话，就不方便计算\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）这个系数，自己定。多少都可以，但是建议给一个能整除的值（这个能整除的数，是还要根\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">据设计稿能整除的数。）</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、对于切的图片，尺寸是根据设计图的尺寸宽度的，显示起来会很大，如果是 Img 标签，可\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">以设置宽度为切出的图片尺寸，换算成 rem，如果是 background-img，用 background-size 属\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">性，设置设计图尺寸宽高，换算成 rem 进行图片的缩放适配。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">对于上述的第二点，根据设计稿动态转换 rem，这里说一下，前面的计算是动态的设置 html 的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">font-size 的大小，这是根据设备的独立像素计算的。而设计稿往往是根据物理像素，即设备像\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">素设计的，往往很大，是 750px 及以上，所以在转换 rem 的时候，转换是根据 psd 设计稿的像\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">素进行转换，即 1rem = 设计稿像素宽度/系数，例如，如果是 1080px 的设计稿，那么，就用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1rem = 1080/18 = 60px（这里用 18 做系数，是因为能整除），然后布局的时候就根据设计稿\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的元素尺寸转换，例如设计稿一个元素的高为 60px，那么就可以转化为 1rem 了。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">特点：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、所有有单位的属性会根据屏幕的尺寸自动计算大小\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、同样一个元素，在不同的设备下的大小是不一样的。在尺寸小的设备下显示的小，在尺寸大\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的设备下显示的大\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、一般以 iphone6 为基准，以它的宽度 750 除上一个系数，再去算 rem\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Tips：上述步骤 2 中换算可以通过 Hbuilder 将 px 自动转 rem 以及通过 less 自动计算成 rem，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">sublime 也可以通过插件进行自动转换。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1.打开 Hbuilder，顶部栏的工具》选项》Hbuilder》代码助手》px 自动转 rem 设置。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2.less 自动转换：Hbuilder 也可以将 less 文件自动转成 css 文件。less 文件的书写如下所示</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>比如想设置宽度为 187px，高度为 100px 的元素，可以通过下面方式计算适配\n@rem：25rem； /*这是 1rem = X px 的 X 的值，但是用了 rem 做单位而已*/\ndiv{\n width: 187/@rem;\n height: 100/@rem;\n}</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">弹性布局适配(会配合 rem 适配使用 )\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">兼容情况\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">IE10 及以上、ios9 及以上、android4.4 及以上版本支持\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">特点\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1.默认所有子元素都会在一行中显示，即使给子元素一个很大的宽度\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2.父级加了这条属性，子级的 float、vertical-align 就会失效\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3.如果兼容低版本的机型要加前缀-webkit-，包括后面讲的所有属性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">容器属性（父元素样式） 具体看菜鸟教程或阮一峰的教程，这里说一下一些重点知识。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1.flex-direction：子元素排列方向（主轴的方向，如果设置了 column，则意味着主轴旋转了 90\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">度）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2.flex-wrap：换行方式\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3.flex-flow：以上两种方式的简写\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4.justify-content：水平对齐方式（子元素在主轴上的对齐方式）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5.align-items：垂直对齐方式（子元素在交叉轴上的对齐方式）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">6.align-content：多行垂直对齐方式（多根轴线的对齐方式）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">项目属性（子元素样式）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1.order：排列位置 //如果有两个的值是相等，按书写顺序排列\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2.flex-grow：扩展比例</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">flex-grow 当父级的宽度大于所有子元素宽度之和时，根据父级的剩余空间，设置子元素的扩\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">展比例（设置后，元素给的固定宽度会被覆盖）它是一个系数默认为 0，即如果存在剩余空间\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">也不扩展。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">剩余空间：剩余空间=父级的宽度-所有子元素的宽度和\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">注意：如果没有设置初始宽度，也没有内容，则默认为 0，否则为内容的宽度。例如设置了文\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">字，会撑开有初始宽度</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>子元素宽度计算公式\n子元素的宽度=（父级的宽度-所有子元素的宽度和）/所有子元素的 flex-grow 属性值之和*子元素的\n属性值+子元素初始宽度</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3.flex-shrink：收缩比例\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">flex-shrink 当所有子元素宽度之和大于父级宽度的时候，根据超出的空间，设置子元素的收缩\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">比例（设置后，元素给的固定宽度会被覆盖）它是一个系数默认为 1，如果给个 0 的话，就不\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">会收缩。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">超出空间：超出空间=所有子元素的宽度和-父级的宽度</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>子元素宽度计算公式\n1、算出超出空间，所有子元素的宽度和-父级的宽度\n2、子元素的初始宽度*子元素的 flex-shrink 值\n3、算出第二步所有结果的和\n4、每个子元素的第二步/第三步*第一步\n5、子元素的初始宽度-第四步</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">flex-basis：元素的大小\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">flex：以上三个属性的简写\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">align-self：单独的垂直对齐方式（交叉轴方向上）</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (46, '如何解决 margin“塌陷”？', 1, '2023-02-09 11:27:03', 0, '外边距塌陷共有两种情况：第一种情况：两个同级元素，垂直排列，上面的盒子给 margin-bottom 下面的盒子给 margintop，那么他们两个的间距会重叠，以大的那个计算。解决这种情况的方法为：两个外边距不同\n时出现。\n第二种情况：两个父子元素，内部的盒子给 margin-top，其父级也会受到影响，同时产生上边\n距，父子元素会进行粘连，决绝这种情况的方法为：父级添加一个 css 属性，overflow：\nhidden，禁止超出。', 21, '<div><spanyes\';font-size:16.08pt;font-family:等线;color:rgb(0,0,0);\">如何解决 m</spanyes\';font-size:16.08pt;font-family:等线;color:rgb(0,0,0);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">外边距塌陷共有两种情况：第一种情况：两个同级元素，垂直排列，上面的盒子给 margin-bottom 下面的盒子给 margintop，那么他们两个的间距会重叠，以大的那个计算。解决这种情况的方法为：两个外边距不同\n时出现。\n第二种情况：两个父子元素，内部的盒子给 margin-top，其父级也会受到影响，同时产生上边\n距，父子元素会进行粘连，决绝这种情况的方法为：父级添加一个 css 属性，overflow：\nhidden，禁止超出。</span></div><div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">外边距重叠就是 margin-collapse\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">解决方案：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）为父盒子设置 border，为外层添加 border 后父子盒子就不是真正意义上的贴合 （可以\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">设置成透明：border：1px solid transparent）。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）为父盒子添加 overflow：hidden；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）为父盒子设定 padding 值；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4）为父盒子添加 position：fixed；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5）为父盒子添加 display：table；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">6）利用伪元素给子元素的前面添加一个空元素\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">.son:before{ content:\"\";\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">overflow:hidden; }</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (47, 'less 和 Scss 的配置使用以及特点？', 1, '2023-02-09 11:28:05', 0, '一.安装依赖\n1 npm install less less-loader --save\n或者\n2 cnpm install less less-loader --save\n二.修改配置\n在 vue 项目中 build/webpack.base.conf.js：', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">一.安装依赖\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1 npm install less less-loader --save\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">或者\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2 cnpm install less less-loader --save\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">二.修改配置\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在 vue 项目中 build/webpack.base.conf.js：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">moduls 对象的 rules 数组中最后添加</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><span style=\"background-color: rgb(241, 241, 241); font-family: couriernew, courier, monospace; font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">{</span></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code> test: /\\.less$/,\n loader: \"style-loader!css-loader!less-loader\"\n }</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">三.引入\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在每个想要使用 less 的 vue 文件中\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">style 加上 lang=“less”\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1 &lt;style lang=\"less\" scoped&gt;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2 &lt;/style&gt;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">scss\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">SCSS 即是 SASS 的新语法，是 Sassy CSS 的简写，是 CSS3 语法的超集，也就是说所有有效的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">CSS3 样式也同样适合于 SASS。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">SASS 是 CSS3 的一个扩展，增加了规则嵌套、变量、混合、选择器继承等等。通过使用命令行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的工具或 WEB 框架插件把它转换成标准的、格式良好的 CSS 代码。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">SCSS 是 Sass 3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">唯一不同的是，SCSS 需要使用分号和花括号而不是换行和缩进。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">SCSS 对空白符号不敏感。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">安装步骤：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">npm install node-sass --save-dev //安装 node-sass \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">npm install sass-loader --save-dev //安装 sass-loader \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">npm install style-loader --save-dev //安装 style-loader\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">出现以下问题可能是版本错误\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Modele build failed: TypeError: this.getResolve is not a function at Object.loader...\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">处理方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">将 \"sass-loader\": \"^8.0.0\"，更换成了 \"sass-loader\": \"^7.3.1\"\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">package.json 中查找替换\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">npm install \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">npm run dev</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">特性：一、（节点）可嵌套性</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">这个是基础，用的太多太多了，必须掌握\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">二、变量\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">变量以$开头（通常网站会有基础变量，譬如基础字体，基础色调等，可以将他们赋值给一个变\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">量，以后调用变量就好了，很类似 js 里的变量）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">三、 Mixins(混合@mixin)：可重用性高，可以注入任何东西\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">注意点：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1.可以相互调用，但是不能拿自己调用自己，形成递归\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2.通过@include 引用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">四、@extend：允许一个选择器继承另一个选择器\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">五、 @function:函数功能，用户使用@function 可以去编写自己的函数（常用）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用语法： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用 @function+函数名称，每个函数都需要有返回值的内容\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">六、引用父元素&amp;：在编译时，&amp;将被替换成父选择符（常用）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">七、计算功能（会用 但是不多吧）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">八、组合连接： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">#{} ： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">变量连接字符串（目前用到的是这个）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">九、循环语句：（很少用到）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">十、if 语句：（很少用到）</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (48, 'css3 新增伪类，以及伪元素？', 1, '2023-02-09 11:28:45', 0, 'CSS3 新增伪类\np:first-of-type 选择属于其父元素的首个<p>元素的每个<p>元素。\np:last-of-type 选择属于其父元素的最后<p>元素的每个<p>元素。\np:nth-child(n) 选择属于其父元素的第 n 个子元素的每个<p>元素。\np:nth-last-child(n) 选择属于其父元素的倒数第 n 个子元素的每个<p>元素。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">CSS3 新增伪类\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">p:first-of-type 选择属于其父元素的首个&lt;p&gt;元素的每个&lt;p&gt;元素。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">p:last-of-type 选择属于其父元素的最后&lt;p&gt;元素的每个&lt;p&gt;元素。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">p:nth-child(n) 选择属于其父元素的第 n 个子元素的每个&lt;p&gt;元素。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">p:nth-last-child(n) 选择属于其父元素的倒数第 n 个子元素的每个&lt;p&gt;元素。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">p:nth-of-type(n) 选择属于其父元素第 n 个&lt;p&gt;元素的每个&lt;p&gt;元素。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">p:nth-last-of-type(n) 选择属于其父元素倒数第 n 个&lt;p&gt;元素的每个&lt;p&gt;元素。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">p:last-child 选择属于其父元素最后一个子元素的每个&lt;p&gt;元素。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">p:target 选择当前活动的&lt;p&gt;元素。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">:not(p) 选择非&lt;p&gt;元素的每个元素。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">:enabled 控制表单控件的可用状态。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">:disabled 控制表单控件的禁用状态。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">:checked 单选框或复选框被选中。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">伪元素\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">::first-letter 将样式添加到文本的首字母\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">::first-line 将样式添加到文本的首行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">::before 在某元素之前插入某些内容\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">::after 在某元素之后插入某些内容</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (49, 'img 的 alt 与 title 的异同，还有实现图片懒加载的原 理？', 1, '2023-02-09 11:29:14', 0, 'alt 是图片加载失败时，显示在网页上的替代文字； title 是鼠标放上面时显示的文字,title 是对\n图片的描述与进一步说明;', 21, '<div><spanyes\';font-size:16.08pt;font-family:等线;color:rgb(0,0,0);\">img 的 alt 与 title 的异同，还有实现图片懒加载的原\n</spanyes\';font-size:16.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:16.08pt;font-family:等线;color:rgb(0,0,0);\">理</spanyes\';font-size:16.08pt;font-family:等线;color:rgb(0,0,0);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">alt 是图片加载失败时，显示在网页上的替代文字；</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">title 是鼠标放上面时显示的文字,title 是对\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">图片的描述与进一步说明;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">这些都是表面上的区别，alt 是 img 必要的属性，而 title 不是。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">对于网站 seo 优化来说，title 与 alt 还有最重要的一点： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">搜索引擎对图片意思的判断，主要靠\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">alt 属性。所以在图片 alt 属性中以简要文字说明，同时包含关键词，也是页面优化的一部分。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">条件允许的话，可以在 title 属性里，进一步对图 片说明。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">由于过多的图片会严重影响网页的加载速度，并且移动网络下的流量消耗巨大，所以说延\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">迟加载几乎是标配了。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">图片懒加载的原理很简单，就是我们先设置图片的 data-set 属性（当然也可以是其他任意\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的，只要不会发送 http 请求就行了，作用就是为了存取值）值为其图片路径，由于不是 src，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">所以不会发送 http 请求。 然后我们计算出页面 scrollTop 的高度和浏览器的高度之和， 如果\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">图片举例页面顶端的坐标 Y（相对于整个页面，而不是浏览器窗口）小于前两者之和，就说明\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">图片就要显示出来了（合适的时机，当然也可以是其他情况），这时候我们再将 data-set 属\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">性替换为 src 属性即可。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (50, 'BFC 是什么？', 1, '2023-02-09 11:30:13', 1, 'BFC(Block formatting context)直译为\"块级格式化上下文\"。它是一个独立的渲染区域，\n只有 Block-level box 参与，它规定了内部的 Block-level Box 如何布局，并且与这个区域\n外部毫不相干', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">BFC(Block formatting context)直译为\"块级格式化上下文\"。它是一个独立的渲染区域，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">只有 Block-level box 参与，它规定了内部的 Block-level Box 如何布局，并且与这个区域\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">外部毫不相干</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">布局规则：A. 内部的 Box 会在垂直方向，一个接一个地放置。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">B. Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">生重叠。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">C. 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">格式化，否则相反)。即使存在浮动也是如此。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">D. BFC 的区域不会与 float box 重叠。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">E. BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">之也如此。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">F. 计算 BFC 的高度时，浮动元素也参与计算。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）哪些元素会生成 BFC：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">A. 根元素\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">B. float 属性不为 none \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">C. position 为 absolute 或 fixed \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">D. display 为 inline-block， table-cell， table-caption， flex， inline-flex \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">F. overflow 不为 visible</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 22, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (51, 'Style 标签写在 body 后与 body 前有什么区别？', 1, '2023-02-09 11:30:42', 0, '1、 写在 body 标签前利于浏览器逐步渲染：\nresources downloading->CSSOM+DOM->RenderTree(composite)->Layout->paint', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、 写</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">2、写在 body 标签后：</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">由于浏览器以逐行方式对 html 文档进行解析；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当解析到写在尾部的样式表（外联或写在 style 标签）会导致浏览器停止之前的渲染，等待加载\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">且解析样式表完成之后重新渲染；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在 windows 的 IE 下可能会出现 FOUC 现象（即样式失效导致的页面闪烁问题）；</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 21, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (52, 'js 的基本类型有哪些？引用类型有哪些？null 和 undefined 的区别？', 1, '2023-02-09 11:33:18', 0, '基本数据类型：number、string、boolean、null、undefined\n引用数据类型：function、object、Array\nundefined:表示变量声明但未初始化时的值\nnull：表示准备用来保存对象，还没有真正保存对象的值。从逻辑角度看，null 值表示一个空对\n象指针。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">基本数据类型：number、string、boolean、null、undefined\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">引用数据类型：function、object、Array\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">undefined:表示变量声明但未初始化时的值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">null：表示准备用来保存对象，还没有真正保存对象的值。从逻辑角度看，null 值表示一个空对\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">象指针。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JavaScript（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ECMAScript 标准）里共有 5 种基本类型：Undefined, Null, Boolean, Number,\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">String，和一种复杂类型 Object。可以看到 null 和 undefined 分属不同的类型，未初始化定义的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">值用 typeof 检测出来是\"undefined\"(字符串)，而 null 值用 typeof 检测出来是\"object\"（字符\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">串）。任何时候都不建议显式的设置一个变量为 undefined，但是如果保存对象的变量还没有\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">真正保存对象，应该设置成 null。实际上，undefined 值是派生自 null 值的，ECMAScript 标准\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">规定对二者进行相等性测试要返回 true</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (53, '如何判断 JavaScript 的数据类型？', 1, '2023-02-09 11:36:07', 2, 'JavaScript 数据类型一共有 7 种：\nUndefined、Null、Boolean、String、Symbol、Number、Object\n除了 Object 之外的 6 种属于原始数据类型。有时，我们还会细分 Object 的类型，比如 Array，\nFunction，Date，RegExp 等。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JavaScript 数据类型一共有 7 种：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Undefined、Null、Boolean、String、Symbol、Number、Object\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">除了 Object 之外的 6 种属于原始数据类型。有时，我们还会细分 Object 的类型，比如 Array，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Function，Date，RegExp 等。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">typeof\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">typeof 可以用来区分除了 Null 类型以外的原始数据类型，对象类型的可以从普通对象里面识别\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">出函数：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>typeof undefined // \"undefined\"\ntypeof null // \"object\"\ntypeof 1 // \"number\"\ntypeof \"1\" // \"string\"\ntypeof Symbol() // \"symbol\"\ntypeof function() {} // \"function\"\ntypeof {} // \"object\"</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">问题一：typeof 不能识别 null，如何识别 null？\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">答案：如果想要判断是否为 null，可以直接使用===全等运算符来判断（或者使用下面的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.prototype.toString 方法）：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>let a = null\na === null // true</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">问题二：typeof 作用于未定义的变量，会报错吗？\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">答案：不会报错，返回\"undefined\"。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>typeof randomVariable // \"undefined\"</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">问题三：typeof Number(1)的返回值是什么？\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">答案：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">\"number\"。注意 Number 和 String 作为普通函数调用的时候，是把参数转化为相应的原\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">始数据类型，也就是类似于做一个强制类型转换的操作，而不是默认当做构造函数调用。注意\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">和 Array 区分，Array(...)等价于 new Array(...)</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>问题三：typeof Number(1)的返回值是什么？\n答案：\"number\"。注意 Number 和 String 作为普通函数调用的时候，是把参数转化为相应的原\n始数据类型，也就是类似于做一个强制类型转换的操作，而不是默认当做构造函数调用。注意\n和 Array 区分，Array(...)等价于 new Array(...)</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">问题四：typeof new Number(1)的返回值是什么？\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">答案：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">\"object\"。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>typeof new Number(1) // \"object\"\ntypeof new String(1) // \"object\"</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">instanceof\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">instanceof 不能用于判断原始数据类型的数据：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>3 instanceof Number // false\n\'3\' instanceof String // false\ntrue instanceof Boolean // false</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">instanceof 可以用来判断对象的类型：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>var date = new Date()\ndate instanceof Date // true\nvar number = new Number()\nnumber instanceof Number // true\nvar string = new String()\nstring instanceof String // true</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">需要注意的是，instanceof 的结果并不一定是可靠的，因为在 ECMAScript7 规范中可以通过自\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">定义 Symbol.hasInstance 方法来覆盖默认行为。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.prototype.toString</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>Object.prototype.toString.call(undefined).slice(8, -1) // \"Undefined\"\nObject.prototype.toString.call(null).slice(8, -1) // \"Null\"\nObject.prototype.toString.call(3).slice(8, -1) // \"Number\"\nObject.prototype.toString.call(new Number(3)).slice(8, -1) // \"Number\"\nObject.prototype.toString.call(true).slice(8, -1) // \"Boolean\"\nObject.prototype.toString.call(\'3\').slice(8, -1) // \"String\"\nObject.prototype.toString.call(Symbol()).slice(8, -1) // \"Symbol</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">由上面的示例可知，该方法没有办法区分数字类型和数字对象类型，同理还有字符串类型和字\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">符串对象类型、布尔类型和布尔对象类型。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">另外，ECMAScript7 规范定义了符号 Symbol.toStringTag，你可以通过这个符号自定义\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.prototype.toString 方法的行为</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>\'use strict\'\nvar number = new Number(3)\nnumber[Symbol.toStringTag] = \'Custom\'\nObject.prototype.toString.call(number).slice(8, -1) // \"Custom\"\nfunction a () {}\na[Symbol.toStringTag] = \'Custom\'\nObject.prototype.toString.call(a).slice(8, -1) // \"Custom\"\nvar array = []\narray[Symbol.toStringTag] = \'Custom\'\nObject.prototype.toString.call(array).slice(8, -1) // \"Custom\"</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">因为 Object.prototype.toString 方法可以通过 Symbol.toStringTag 属性来覆盖默认行为，所以使\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">用这个方法来判断数据类型也不一定是可靠的。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Array.isArray\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Array.isArray(value)可以用来判断 value 是否是数组：<br><pre><code>Array.isArray([]) // true\nArray.isArray({}) // false\n(function () {console.log(Array.isArray(arguments))}()) // false</code></pre><p><br></p></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (54, '创建对象有几种方法', 1, '2023-02-09 11:36:36', 1, '1、字面量对象 // 默认这个对象的原型链指向 object\nvar o1 = {name: \'01\'};\n2、通过 new Object 声明一个对象\nvar o11 = new Object({name: \'011\'});\n3、使用显式的构造函数创建对象\nvar M = function(){this.name=\'o2\'};\nvar o2 = new M();\no2.__proto__=== M.prototype\no2 的构造函数是 M\no2 这个普通函数，是 M 这个构造函数的实例\n4、object.create()\nvar P = {name:\'o3\'};\nvar o3 = Object.create(P);', 21, '<div><spanyes\';font-size:16.08pt;font-family:等线;color:rgb(0,0,0);\">创</spanyes\';font-size:16.08pt;font-family:等线;color:rgb(0,0,0);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">1、字面量对象 // 默认这个对象的原型链指向 object</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">var o1 = {name: \'01\'};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、通过 new Object 声明一个对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">var o11 = new Object({name: \'011\'});\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3、使用显式的构造函数创建对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">var M = function(){this.name=\'o2\'};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">var o2 = new M();\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">o2.__proto__=== M.prototype\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">o2 的构造函数是 M\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">o2 这个普通函数，是 M 这个构造函数的实例\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">4、object.create()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">var P = {name:\'o3\'};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">var o3 = Object.create(P);</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (55, '简述创建函数的几种方式？', 1, '2023-02-09 11:37:22', 0, '第一种（函数声明）、第二种（函数表达式）、第三种（函数对象方式）', 21, '<div><spanyes\';font-size:16.08pt;font-family:等线;color:rgb(0,0,0);\">简述创建函数的几种方式？</spanyes\';font-size:16.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:16.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>第一种（函数声明）：\nfunction sum1(num1,num2){ \nreturn num1+num2; \n}\n第二种（函数表达式）\nvar sum2 = function(num1,num2){ \nreturn num1+num2; \n}\n第三种（函数对象方式）\nvar sum3 = new Function(\"num1\",\"num2\",\"return num1+num2\");</code></pre><p><br></p></spanyes\';font-size:16.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (56, 'Javascript 创建对象的几种方式？', 1, '2023-02-09 11:41:49', 0, '1、字面量对象 // 默认这个对象的原型链指向 object\nvar o1 = {name: \'01\'};\n2、通过 new Object 声明一个对象\nvar o11 = new Object({name: \'011\'});\n3、使用显式的构造函数创建对象\nvar M = function(){this.name=\'o2\'};\nvar o2 = new M();\no2.__proto__=== M.prototype\no2 的构造函数是 M\no2 这个普通函数，是 M 这个构造函数的实例\n4、object.create()\nvar P = {name:\'o3\'};\nvar o3 = Object.create(P);', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1. 简单对象的创建 使用对象字面量的方式{}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">创建一个对象（最简单，好理解，推荐使用）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">代码如下</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>var Cat = {};//JSON\nCat.name=\"kity\";//添加属性并赋值\nCat.age=2; \nCat.sayHello=function(){ \nalert(\"hello \"+Cat.name+\",今年\"+Cat[\"age\"]+\"岁了\");//可以使用“.”的方式访问属性，\n也可以使用 HashMap 的方式访问\n<p>}<br>Cat.sayHello();//调用对象的（方法）函数</p></code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2.用 function(函数)来模拟 class \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2.1 创建一个对象，相当于 new 一个类的实例(无参构造函数)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">代码如下</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>function Pet(name,age,hobby){ \nthis.name=name;//this 作用域：当前对象\nthis.age=age; \nthis.hobby=hobby; \nthis.eat=function(){ \nalert(\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",也是个吃货\"); \n} \n}\nvar maidou =new Pet(\"麦兜\",5,\"睡觉\");//实例化/创建对象\nmaidou.eat();//调用 eat 方法(函数)</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3.使用工厂方式来创建（Object 关键字）</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><span style=\"background-color: rgb(241, 241, 241); font-family: couriernew, courier, monospace; font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">var wcDog =new Object();&nbsp;</span></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>wcDog.name=\"旺财\"; \nwcDog.age=3; \nwcDog.work=function(){ \nalert(\"我是\"+wcDog.name+\",汪汪汪......\"); \n}\nwcDog.work();</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4.使用原型对象的方式 prototype 关键字</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>function Dog(){ \n}\nDog.prototype.name=\"旺财\"; \nDog.prototype.eat=function(){\nalert(this.name+\"是个吃货\"); \n}\nvar wangcai =new Dog(); \nwangcai.eat();</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5.混合模式(原型和构造函数)</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>function Car(name,price){ \nthis.name=name; \nthis.price=price; \n}\nCar.prototype.sell=function(){ \nalert(\"我是\"+this.name+\"，我现在卖\"+this.price+\"万元\"); \n} \nvar camry =new Car(\"凯美瑞\",27); \ncamry.sell();</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">6.动态原型的方式(可以看作是混合模式的一种特例)</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><pre><code>function Car(name,price){ \nthis.name=name; \nthis.price=price; \nif(typeof Car.sell==\"undefined\"){ \nCar.prototype.sell=function(){ \nalert(\"我是\"+this.name+\"，我现在卖\"+this.price+\"万元\"); \n} \nCar.sell=true; \n} \n}\nvar camry =new Car(\"凯美瑞\",27); \ncamry.sell();</code></pre><p><br></p><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&nbsp;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (57, '请指出 JavaScript 宿主对象和原生对象的区别？', 1, '2023-02-09 11:42:19', 0, '原生对象\nECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的\n对象”。\n“本地对象”包含哪些内容：Object、Function、Array、String、Boolean、Number、Date、\nRegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError。\n由此可以看出，本地对象就是 ECMA-262 定义的类（引用类型）。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">原生对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">对象”。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">“本地对象”包含哪些内容：Object、Function、Array、String、Boolean、Number、Date、\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">由此可以看出，本地对象就是 ECMA-262 定义的类（引用类型）。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">内置对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ECMA-262 把内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">对象，它已被实例化了。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">同样是“独立于宿主环境”。根据定义我们似乎很难分清“内置对象”与“本地对象”的区\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">别。而 ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">义，每个内置对象都是本地对象）。如此就可以理解了。内置对象是本地对象的一种。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">宿主对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">何为“宿主对象”？主要在这个“宿主”的概念上，ECMAScript 中的“宿主”当然就是我们网\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">页的运行环境，即“操作系统”和“浏览器”。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">象。所有的 BOM 和 DOM 都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">其实说白了就是，ECMAScript 官方未定义的对象都属于宿主对象，因为其未定义的对象大多数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">是自己通过 ECMAScript 程序创建的对象</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (58, 'Javascript 内置的常用对象有哪些？并列举该对象常用 的方法？', 1, '2023-02-09 11:44:05', 4, 'Arguments 函数参数集合\narguments[ ] 函数参数的数组\nArguments 一个函数的参数和其他属性\nArguments.callee 当前正在运行的函数\nArguments.length 传递给函数的参数的个数\nArray 数组\nlength 属性 动态获取数组长度\njoin() 将一个数组转成字符串。返回一个字符串。\nreverse() 将数组中各元素颠倒顺序\ndelete 运算符 只能删除数组元素的值，而所占空间还在，总长度没变(arr.length)。\nshift() 删除数组中第一个元素，返回删除的那个值，并将长度减 1。\npop() 删除数组中最后一个元素，返回删除的那个值，并将长度减 1。\nunshift() 往数组前面添加一个或多个数组元素，长度要改变。arrObj.unshift(“a” ，\n“b，“c”)\npush() 往数组结尾添加一个或多个数组元素，长度要改变。arrObj.push(“a” ，“b”，\n“c”)\nconcat( ) 连接数组\nslice( ) 返回数组的一部分\nsort( ) 对数组元素进行排序\nsplice( ) 插入、删除或替换数组的元素\ntoLocaleString( ) 把数组转换成局部字符串\ntoString( ) 将数组转换成一个字符串', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Arguments 函数参数集合\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">arguments[ ] 函数参数的数组\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Arguments 一个函数的参数和其他属性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Arguments.callee 当前正在运行的函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Arguments.length 传递给函数的参数的个数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Array 数组\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">length 属性 动态获取数组长度\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">join() 将一个数组转成字符串。返回一个字符串。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">reverse() 将数组中各元素颠倒顺序\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">delete 运算符 只能删除数组元素的值，而所占空间还在，总长度没变(arr.length)。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">shift() 删除数组中第一个元素，返回删除的那个值，并将长度减 1。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">pop() 删除数组中最后一个元素，返回删除的那个值，并将长度减 1。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">unshift() 往数组前面添加一个或多个数组元素，长度要改变。arrObj.unshift(“</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">a” ，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">“</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">b，“</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">c”)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">push() 往数组结尾添加一个或多个数组元素，长度要改变。arrObj.push(“</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">a” ，“</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">b”，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">“</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">c”)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">concat( ) 连接数组\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">slice( ) 返回数组的一部分\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">sort( ) 对数组元素进行排序\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">splice( ) 插入、删除或替换数组的元素\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">toLocaleString( ) 把数组转换成局部字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">toString( ) 将数组转换成一个字符串</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">forEach 遍历所有元素\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">var arr = [1, 2, 3];\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">arr.forEach(function(item, index) {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">// 遍历数组的所有元素\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">console.log(index, item);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">});\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">every 判断所有元素是否都符合条件</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">sort 排序</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">map 对元素重新组装，生成新数组</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">filter 过滤符合条件的元素</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Boolean 布尔对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）创建当前(现在)日期对象的实例，不带任何参数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var today = new Date()；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）创建指定时间戳的日期对象实例，参数是时间戳。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">时间戳：是指某一个时间距离 1970 年 1 月 1 日 0 时 0 分 0 秒，过去了多少毫秒值(1 秒\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">=1000 毫秒)。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var timer = new Date(10000)； </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//时间是 1970 年 1 月 1 日 0 时 0 分 10 秒\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）指定一个字符串的日期时间信息，参数是一个日期时间字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var timer = new Date(“2015/5/25 10：00：00”)；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4）指定多个数值参数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var timer = new Date(2015+100，4，25，10，20，0)； </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//顺序为：年、月、日、\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">时、分、秒，年、月、日是必须的。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">方法：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getDate( ) 返回一个月中的某一天\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getDay( ) 返回一周中的某一天\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getFullYear( ) 返回 Date 对象的年份字段\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getHours( ) 返回 Date 对象的小时字段\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getMilliseconds( ) 返回 Date 对象的毫秒字段\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getMinutes( ) 返回 Date 对象的分钟字段\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getMonth( ) 返回 Date 对象的月份字段\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getSeconds( ) 返回 Date 对象的秒字段\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getTime( ) 返回 Date 对象的毫秒表示\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getTimezoneOffset( ) 判断与 GMT 的时间差\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getUTCDate( ) 返回该天是一个月的哪一天(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getUTCDay( ) 返回该天是星期几(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getUTCFullYear( ) 返回年份(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getUTCHours( ) 返回 Date 对象的小时字段(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getUTCMilliseconds( ) 返回 Date 对象的毫秒字段(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getUTCMinutes( ) 返回 Date 对象的分钟字段(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getUTCMonth( ) 返回 Date 对象的月份(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getUTCSeconds( ) 返回 Date 对象的秒字段(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.getYear( ) 返回 Date 对象的年份字段(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.parse( ) 解析日期/时间字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setDate( ) 设置一个月的某一天\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setFullYear( ) 设置年份，也可以设置月份和天\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setHours( ) 设置 Date 对象的小时字段、分钟字段、秒字段和毫秒字段\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setMilliseconds( ) 设置 Date 对象的毫秒字段\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setMinutes( ) 设置 Date 对象的分钟字段和秒字段\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setMonth( ) 设置 Date 对象的月份字段和天字段\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setSeconds( ) 设置 Date 对象的秒字段和毫秒字段\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setTime( ) 以毫秒设置 Date 对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setUTCDate( ) 设置一个月中的某一天(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setUTCFullYear( ) 设置年份、月份和天(世界时)</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Boolean.toString( ) 将布尔值转换成字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Boolean.valueOf( ) Boolean 对象的布尔值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date 日期时间\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">创建 Date 对象的方法</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setUTCHours( ) 设置 Date 对象的小时字段、分钟字段、秒字段和毫秒字段(世界\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setUTCMilliseconds( ) 设置 Date 对象的毫秒字段(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setUTCMinutes( ) 设置 Date 对象的分钟字段和秒字段(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setUTCMonth( ) 设置 Date 对象的月份字段和天数字段(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setUTCSeconds( ) 设置 Date 对象的秒字段和毫秒字段(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.setYear( ) 设置 Date 对象的年份字段\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.toDateString( ) 返回 Date 对象日期部分作为字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.toGMTString( ) 将 Date 转换为世界时字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.toLocaleDateString( ) 回 Date 对象的日期部分作为本地已格式化的字符\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.toLocaleString( ) 将 Date 转换为本地已格式化的字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.toLocaleTimeString( ) 返回 Date 对象的时间部分作为本地已格式化的字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.toString( ) 将 Date 转换为字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.toTimeString( ) 返回 Date 对象日期部分作为字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.toUTCString( ) 将 Date 转换为字符串(世界时)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.UTC( ) 将 Date 规范转换成毫秒数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Date.valueOf( ) 将 Date 转换成毫秒表示\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Error 异常对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Error.message 可以读取的错误消息\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Error.name 错误的类型\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Error.toString( ) 把 Error 对象转换成字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">EvalError 在不正确使用 eval()时抛出\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">SyntaxError 抛出该错误用来通知语法错误\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">RangeError 在数字超出合法范围时抛出\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ReferenceError 在读取不存在的变量时抛出\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">TypeError 当一个值的类型错误时，抛出该异常\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">URIError 由 URl 的编码和解码方法抛出\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Function 函数构造器\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Function.apply( ) 将函数作为一个对象的方法调用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Function.arguments[] 传递给函数的参数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Function.call( ) 将函数作为对象的方法调用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Function.caller 调用当前函数的函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Function.length 已声明的参数的个数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Function.prototype 对象类的原型\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Function.toString( ) 把函数转换成字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Math 数学对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Math 对象是一个静态对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Math.PI 圆周率。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Math.abs() 绝对值。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Math.ceil() 向上取整(整数加 1，小数去掉)。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Math.floor() 向下取整(直接去掉小数)。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Math.round() 四舍五入。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">split() 将一个字符串转成数组。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">charCodeAt( ) 返回字符串中的第 n 个字符的代码\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">concat( ) 连接字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">fromCharCode( ) 从字符编码创建—个字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">indexOf( ) 返回一个子字符串在原始字符串中的索引值(查找顺序从左往右查找)。如果没\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">有找到，则返回-1。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">lastIndexOf( ) 从后向前检索一个字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">localeCompare( ) 用本地特定的顺序来比较两个字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">match( ) 找到一个或多个正则表达式的匹配\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">replace( ) 替换一个与正则表达式匹配的子串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">search( ) 检索与正则表达式相匹配的子串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">slice( ) 抽取一个子串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">toLocaleLowerCase( ) 把字符串转换小写\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">toLocaleUpperCase( ) 将字符串转换成大写\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">toLowerCase( ) 将字符串转换成小写\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">toString( ) 返回字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">toUpperCase( ) 将字符串转换成大写</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Math.pow(x，y) 求 x 的 y 次方。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Math.sqrt() 求平方根。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Number 数值对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Number.MAX_VALUE 最大数值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Number.MIN_VALUE 最小数值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Number.NaN 特殊的非数字值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Number.NEGATIVE_INFINITY 负无穷大\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Number.POSITIVE_INFINITY 正无穷大\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Number.toExponential( ) 用指数计数法格式化数字\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Number.toFixed( ) 采用定点计数法格式化数字\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Number.toLocaleString( ) 把数字转换成本地格式的字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Number.toPrecision( ) 格式化数字的有效位\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Number.toString( ) 将—个数字转换成字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Number.valueOf( ) 返回原始数值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object 基础对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object 含有所有 JavaScript 对象的特性的超类\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.constructor 对象的构造函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.hasOwnProperty( ) 检查属性是否被继承\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.isPrototypeOf( ) 一个对象是否是另一个对象的原型\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.propertyIsEnumerable( ) 是否可以通过 for/in 循环看到属性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.toLocaleString( ) 返回对象的本地字符串表示\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.toString( ) 定义一个对象的字符串表示\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.valueOf( ) 指定对象的原始值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">RegExp 正则表达式对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">RegExp.exec( ) 通用的匹配模式\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">RegExp.global 正则表达式是否全局匹配\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">RegExp.ignoreCase 正则表达式是否区分大小写\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">RegExp.lastIndex 下次匹配的起始位置\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">RegExp.source 正则表达式的文本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">RegExp.test( ) 检测一个字符串是否匹配某个模式\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">RegExp.toString( ) 把正则表达式转换成字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">String 字符串对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Length 获取字符串的长度。如：var len = strObj.length \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">toLowerCase() 将字符串中的字母转成全小写。如：strObj.toLowerCase()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">toUpperCase() 将字符串中的字母转成全大写。如：strObj.toUpperCase()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">charAt(index) 返回指定下标位置的一个字符。如果没有找到，则返回空字符串。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">substr() 在原始字符串，返回一个子字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">substring() 在原始字符串，返回一个子字符串。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">区别：\'\'\'\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">“abcdefgh”.substring(2，3) = “</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">c”\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">“abcdefgh”.substr(2，3) = “cde</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (59, '=== 和 ==的区别？', 1, '2023-02-09 11:44:35', 0, '===：三个等号我们称为等同符，当等号两边的值为相同类型的时候，直接比较等号两边的\n值，值相同则返回 true，若等号两边的值类型不同时直接返回 false。也就是说三个等号既要判\n断值也要判断类型是否相等。\n==：两个等号我们称为等值符，当等号两边的值为相同类型时比较值是否相同，类型不同时会\n发生类型的自动转换，转换为相同的类型后再作比较。也就是说两个等号只要值相等就可以。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">===：三个等号我们称为等同符，当等号两边的值为相同类型的时候，直接比较等号两边的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">值，值相同则返回 true，若等号两边的值类型不同时直接返回 false。也就是说三个等号既要判\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">断值也要判断类型是否相等。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">==：两个等号我们称为等值符，当等号两边的值为相同类型时比较值是否相同，类型不同时会\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">发生类型的自动转换，转换为相同的类型后再作比较。也就是说两个等号只要值相等就可以。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (60, 'null，undefined 的区别', 1, '2023-02-09 11:45:00', 0, 'null 表示一个对象被定义了，值为“空值”；\nundefined 表示不存在这个值。\ntypeof undefined //\"undefined\"\nundefined :是一个表示\"无\"的原始值或者说表示\"缺少值\"，就是此处应该有一个值，但是还没有\n定义。当尝试读取时会返回 undefined；\n例如变量被声明了，但没有赋值时，就等于 undefined\ntypeof null //\"object\"\nnull : 是一个对象(空对象, 没有任何属性和方法)；', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">null 表示一个对象被定义了，值为“空值”；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">undefined 表示不存在这个值。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">typeof undefined //\"undefined\"\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">undefined :是一个表示\"无\"的原始值或者说表示\"缺少值\"，就是此处应该有一个值，但是还没有\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">定义。当尝试读取时会返回 undefined；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">例如变量被声明了，但没有赋值时，就等于 undefined\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">typeof null //\"object\"\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">null : 是一个对象(空对象, 没有任何属性和方法)；</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">例如作为函数的参数，表示该函数的参数不是对象；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">注意：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">在验证 null 时，一定要使用=== ，因为 == 无法分别 null 和 undefined\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">undefined 表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。典型用法是：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1）变量被声明了，但没有赋值时，就等于 undefined。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2) 调用函数时，应该提供的参数没有提供，该参数等于 undefined。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3）对象没有赋值的属性，该属性的值为 undefined。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">4）函数没有返回值时，默认返回 undefined。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">null 表示\"没有对象\"，即该处不应该有值。典型用法是：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1） 作为函数的参数，表示该函数的参数不是对象。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2） 作为对象原型链的终点。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (61, 'Js 中什么情况下会返回 undefined 值？（必会）', 1, '2023-02-09 11:46:06', 0, '  1、访问声明，但是没有初始化的变量2、访问不存在的属性3、访问函数的参数没有被显式的传递值4、访问任何被设置为 undefined 值的变量5、没有定义 return 的函数隐式返回6、函数 return 没有显式的返回任何内容', 21, '<p>1、访问声明，但是没有初始化的变量</p><p>2、访问不存在的属性</p><p>3、访问函数的参数没有被显式的传递值</p><p>4、访问任何被设置为 undefined 值的变量</p><p>5、没有定义 return 的函数隐式返回</p><p>6、函数 return 没有显式的返回任何内容</p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (62, '如何区分数组和对象？', 1, '2023-02-09 11:46:48', 1, '方法一：通过 ES6 中的 Array.isArray 来识别方法二：通过 instanceof 来识别方法三：通过调用 constructor 来识别方法四：通过 Object.prototype.toString.call 方法来识别', 21, '<p>方法一：通过 ES6 中的 Array.isArray 来识别</p><p>方法二：通过 instanceof 来识别</p><p>方法三：通过调用 constructor 来识别</p><p>方法四：通过 Object.prototype.toString.call 方法来识别</p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (63, '怎么判断两个对象相等？', 1, '2023-02-09 11:48:03', 0, 'ES6 中有一个方法判断两个对象是否相等，这个方法判断是两个对象引用地址是否一致', 21, '<pre><code><p>ES6 中有一个方法判断两个对象是否相等，这个方法判断是两个对象引用地址是否一致</p>\nlet obj1= {\n a: 1\n }\n let obj2 = {\n a: 1\n }\nconsole.log(Object.is(obj1, obj2)) // false\nlet obj3 = obj1\nconsole.log(Object.is(obj1, obj3)) // true\nconsole.log(Object.is(obj2, obj3)) // false</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当需求是比较两个对象内容是否一致时就没用了。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">想要比较两个对象内容是否一致，思路是要遍历对象的所有键名和键值是否都一致：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、判断两个对象是否指向同一内存\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、使用 Object.getOwnPropertyNames 获取对象所有键名数组\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、判断两个对象的键名数组是否相等\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4、遍历键名，判断键值是否都相等</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>let obj1 = {\n a: 1,\n b: {\n c: 2\n }\n }\n let obj2 = {\n b: {\n c: 3\n },\n a: 1\n }\n function isObjectValueEqual(a, b) {\n // 判断两个对象是否指向同一内存，指向同一内存返回 true\nif (a === b) return true\n // 获取两个对象键值数组\n let aProps = Object.getOwnPropertyNames(a)\n let bProps = Object.getOwnPropertyNames(b)\n // 判断两个对象键值数组长度是否一致，不一致返回 false\n if (aProps.length !== bProps.length) return false\n // 遍历对象的键值\n for (let prop in a) {\n // 判断 a 的键值，在 b 中是否存在，不存在，返回 false\n if (b.hasOwnProperty(prop)) {\n // 判断 a 的键值是否为对象，是则递归，不是对象直接判断键值是否相等，不相等返回 false\n if (typeof a[prop] === \'object\') {\n if (!isObjectValueEqual(a[prop], b[prop])) return false\n } else if (a[prop] !== b[prop]) {\n return false\n }\n } else {\n return false\n }\n }\n return true\n }\n console.log(isObjectValueEqual(obj1, obj2)) // false</code></pre><p><br></p></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (64, '列举三种强制类型转换和两种隐式类型转换？', 1, '2023-02-09 11:48:28', 0, '强制\n转化成字符串 toString() String()\n转换成数字 Number()、 parseInt()、 parseFloat()\n转换成布尔类型 Boolean()\n隐式\n拼接字符串\n例子 var str = \"\" + 18 \n- / % === ==', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">强制\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">转化成字符串 toString() String()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">转换成数字 Number()、 parseInt()、 parseFloat()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">转换成布尔类型 Boolean()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">隐式\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">拼接字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">例子 var str = \"\" + 18 \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">- / % === ==</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (65, 'Js 中怎么获取当前日期的月份？', 1, '2023-02-09 11:48:47', 0, 'JavaScript 中获得当前日期是使用 new Date 这个内置对象的实例，其他一些进阶的操作也是基\n于这个内置对象的实例。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JavaScript 中获得当前日期是使用 new Date 这个内置对象的实例，其他一些进阶的操作也是基\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">于这个内置对象的实例。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">获取完整的日期（默认格式）：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var date = new Date; // Sat Jul 06 2019 19:59:27 GMT+0800 (中国标准时间)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">获取当前年份：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var year = date.getFullYear(); // 2019\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">获取当前月份：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var month = date.getMonth() + 1; // 7\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">获取当前日：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var day = date.getDay(); // 6\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">获取当前日期（年-月-日）：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">month = (month &gt; 9) ? month : (\"0\" + month);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">day = (day &lt; 10) ? (\"0\" + day) : day;var today = year + \"-\" + month + \"-\" + day; // 2019-07-06\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">另外的一些操作：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">date.getYear(); // 获取当前年份(2 位)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">date.getFullYear(); // 获取完整的年份(4 位, 1970-????)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">date.getMonth(); // 获取当前月份(0-11,0 代表 1 月)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">date.getDate(); // 获取当前日(1-31)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">date.getDay(); // 获取当前星期 X(0-6,0 代表星期天)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">date.getTime(); // 获取当前时间(从 1970.1.1 开始的毫秒数)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">date.getHours(); // 获取当前小时数(0-23)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">date.getMinutes(); // 获取当前分钟数(0-59)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">date.getSeconds(); // 获取当前秒数(0-59)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">date.getMilliseconds(); // 获取当前毫秒数(0-999)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">date.toLocaleDateString(); // 获取当前日期\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">date.toLocaleTimeString(); // 获取当前时间\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">date.toLocaleString( ); // 获取日期与时间</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (66, '什么是类数组（伪数组），如何将其转化为真实的数 组？', 1, '2023-02-09 13:21:44', 0, '1、具有 length 属性\n2、按索引方式存储数据\n3、不具有数组的 push.pop 等方法\n伪数组（类数组）：无法直接调用数组方法或期望 length 属性有什么特殊的行为，不具有数组\n的 push.pop 等方法，但仍可以对真正数据遍历方法来遍历它们。典型的是函数\ndocument.childNodes 之类的，它们返回的 NodeList 对象都属于伪数组。', 21, '<p>​<span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">1、具有 length 属性</span><br></p><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、按索引方式存储数据\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、不具有数组的 push.pop 等方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">伪数组（类数组）：无法直接调用数组方法或期望 length 属性有什么特殊的行为，不具有数组\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的 push.pop 等方法，但仍可以对真正数据遍历方法来遍历它们。典型的是函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">document.childNodes 之类的，它们返回的 NodeList 对象都属于伪数组。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (67, '如何遍历对象的属性', 1, '2023-02-09 13:22:36', 0, '1、遍历自身可枚举的属性 (可枚举，非继承属性) Object.keys() 方法\n该方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中的属性名的排列顺序\n和使用 for..in 遍历该对象时返回的顺序一致（两者的区别是 for ..in 还会枚举其原型链上的属\n性 ）', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、遍历自身可枚举的属性 (可枚举，非继承属性) Object.keys() 方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">该方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中的属性名的排列顺序\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">和使用 for..in 遍历该对象时返回的顺序一致（两者的区别是 for ..in 还会枚举其原型链上的属\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">性 ）</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、遍历自身的所有属性(可枚举，不可枚举，非继承属性) Object.getOwnPropertyNames()方法</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">该方法返回一个由指定对象的所有自身属性组成的数组(包括不可枚举属性但不包括 Symbol 值</span></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">作为名称的属性)</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、遍历可枚举的自身属性和继承属性 （可枚举，可继承的属性） for in\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">遍历对象的属性</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4、遍历所有的自身属性和继承属性</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><br></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (68, 'Src 和 href 的区别是？', 1, '2023-02-09 13:22:58', 1, 'src（source）指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在\n请求 src 资源时会将其指向的资源下载并应用到文档中，如 js 脚本，img 图片和 iframe 等\n元素。\n当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行\n完毕，类似于将所指向资源嵌入当前标签内。\nhref（hypertext reference/超文本引用）指向网络资源所在位置，建立和当前元素（锚点）\n或当前文档（链接）之间的链接，如果我们在文档中添加<link href=\"common.css\"\nrel=\"stylesheet\"/>那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止\n对当前文档的处理。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">src（source）指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">请求 src 资源时会将其指向的资源下载并应用到文档中，如 js 脚本，img 图片和 iframe 等\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">元素。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">完毕，类似于将所指向资源嵌入当前标签内。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">href（hypertext reference/超文本引用）指向网络资源所在位置，建立和当前元素（锚点）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">或当前文档（链接）之间的链接，如果我们在文档中添加&lt;link href=\"common.css\"\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">rel=\"stylesheet\"/&gt;那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">对当前文档的处理。&nbsp;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 21, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (69, '如何使用原生 js 给一个按钮绑定两个 onclick 事件？', 1, '2023-02-09 13:23:29', 0, '如何使用原生 js 给一个按钮绑定两个 onclick 事件', 21, '<pre><code>Var btn=document.getElementById(‘btn’);\n//事件监听 绑定多个事件\nvar btn4 = document.getElementById(\"btn4\");\nbtn4.addEventListener(\"click\",hello1);\nbtn4.addEventListener(\"click\",hello2);\nfunction hello1(){\n alert(\"hello 1\");\n}\nfunction hello2(){\n alert(\"hello 2\")}</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (70, '如何在 JavaScript 中比较两个对象？', 1, '2023-02-09 13:24:40', 0, '使用 == 或 === 对两个不同却具有相同属性及属性值的对象进行比较，他们的结果却不会相\n等。这是因为等号比较的是他们的引用（内存地址），而不是基本类型。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用 == 或 === 对两个不同却具有相同属性及属性值的对象进行比较，他们的结果却不会相\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">等。这是因为等号比较的是他们的引用（内存地址），而不是基本类型。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">为了测试两个对象在结构上是否相等，需要一个辅助函数。 他将遍历每个对象的所有属性，然\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">后测试他们是否具有相同的值，嵌套对象也需如此。当然，也可以使用参数来控制是否对原型\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">链进行比较。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">加分回答：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">像数字和字符串这样的基本类型只需对比他们的值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当一个对象赋值给另一个新对象时，使用等号进行对比，他们就会相等。因为他们的引用（内\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">存地址）是同一个</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (71, 'JavaScript 中的作用域、预解析与变量声明提升？', 1, '2023-02-09 13:25:39', 0, '作用域: 就是变量的有效范围。 在一定的空间里可以对数据进行读写操作，这个空间就是数据\n的作用域。\n1、全局作用域： 最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以\n访问的；\n2、局部作用域： 局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访\n问的，最常见的例如函数内部。在 ES6 之前，只有函数可以划分变量的作用域，所以在函数\n的外面无法访问函数内的变量。\n3、块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫块级作用域。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">作用域: 就是变量的有效范围。 在一定的空间里可以对数据进行读写操作，这个空间就是数据\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的作用域。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、全局作用域： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">访问的；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、局部作用域： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">问的，最常见的例如函数内部。在 ES6 之前，只有函数可以划分变量的作用域，所以在函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的外面无法访问函数内的变量。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、块级作用域：凡是代码块就可以划分变量的作用域，这种作用域的规则就叫块级作用域。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">块级作用域 函数作用域 词法作用域之间的区别：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、块级作用域和函数作用域描述的是，什么东西可以划分变量的作用域\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、词法作用域描述的是，变量的查找规则。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">之间的关系：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）、 块级作用域 包含 函数作用域。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）、 词法作用域 与 块级作用域、函数作用域之间没有任何交集， 他们从两个角度描述了\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">作用域的规则。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 之前 js 采用的是函数作用域+词法作用域，ES6 js 采用的是块级作用域+词法作用域 。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">预解析：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JavaScript 代码的执行是由浏览器中的 JavaScript 解析器来执行的。JavaScript 解析器执行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JavaScript 代码的时候，分为两个过程：预解析过程和代码执行过程</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">预解析过程：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1.把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2.把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3.先提升 var，在提升 function。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">变量提升\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">变量提升：定义变量的时候，变量的声明会被提升到作用域的最上面，变量的赋值不会提升。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">函数提升：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JavaScript 解析器首先会把当前作用域的函数声明提前到整个作用域的最前面</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">变量声明提升：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用 var 关键字定义的变量，被称为变量声明；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">函数声明提升的特点是，在函数声明的前面，可以调用这个函数。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (72, '变量提升与函数提升的区别？', 1, '2023-02-09 13:25:59', 0, '简单说就是在 js 代码执行前引擎会先进行预编译，预编译期间会将变量声明与函数声明提升至\n其对应作用域的最顶端，函数内声明的变量只会提升至该函数作用域最顶层。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">变量提升：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">简单说就是在 js 代码执行前引擎会先进行预编译，预编译期间会将变量声明与函数声明提升至\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">其对应作用域的最顶端，函数内声明的变量只会提升至该函数作用域最顶层。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当函数内部定义的一个变量与外部相同时，那么函数体内的这个变量就会被上升到最顶端。 举\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">例来说：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">console.log(a); //\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">undefined var a = 3;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//预编译后的代码结构可以看做如下运行顺序 var a; // 将变量 a 的声明提升至最顶端，赋值逻\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">辑不提升。 console.log(a);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">// undefined a = 3; // 代码执行到原位置即执行原赋值逻辑\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">函数提升： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">函数提升只会提升函数声明式写法，函数表达式的写法不存在函数提升。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">函数提升的优先级大于变量提升的优先级，即函数提升在变量提升之上</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (73, '什么是作用域链？', 1, '2023-02-09 13:26:30', 0, '什么是作用域链？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当代码在一个环境中执行时，会创建变量对象的一个作用域链。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">由子级作用域返回父级作用域中寻找变量，就叫做作用域链。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">作用域链中的下一个变量对象来自包含环境，也叫外部环境。而再下一个变量对象则来自下一\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">个包含环境，一直延续到全局执行环境。全局执行环境的变量对象始终都是作用域链中的最后\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">一个对象。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">作用域链前端始终都是当前执行的代码所在环境的变量对象，如果环境是函数，则将其活动对\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">象作为变量对象。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (74, '如何延长作用域链？', 1, '2023-02-09 13:26:53', 0, '执行环境的类型只有两种，全局和局部（函数）。但是有些语句可以在作用域链的前端临时增\n加一个变量对象，该变量对象会在代码执行后被移除。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">作用域链是可以延长的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">延长作用域链：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">执行环境的类型只有两种，全局和局部（函数）。但是有些语句可以在作用域链的前端临时增\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">加一个变量对象，该变量对象会在代码执行后被移除。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">具体来说就是执行这两个语句时，作用域链都会得到加强。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、try - catch 语句的 catch 块；会创建一个新的变量对象，包含的是被抛出的错误对象的声\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">明。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、with 语句。with 语句会将指定的对象添加到作用域链中</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (75, '判断一个值是什么类型有哪些方法？', 1, '2023-02-09 13:27:19', 0, 'typeof 运算符\n• instanceof 运算符\ninstanceof 严格来说是 Java 中的一个双目运算符，用来测试一个对象是否为一个类的', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">typeof 运算符\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">instanceof 运算符\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">instanceof 严格来说是 Java 中的一个双目运算符，用来测试一个对象是否为一个类的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">实例，用法为：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">// 判断 foo 是否是 Foo 类的实例\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">function Foo(){} \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">var foo = new Foo(); \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">console.log(foo instanceof Foo) //true\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.prototype.toString 方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在 JavaScript 里使用 typeof 来判断数据类型，只能区分基本类型，即\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">“number”，”string”，”undefined”，”boolean”，”object”，“function”，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">“symbol” (ES6 新增)七种。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">对于数组、null、对象来说，其关系错综复杂，使用 typeof 都会统一返回 “object”\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">字符串。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">要想区别对象、数组、函数单纯使用 typeof 是不行的，JavaScript 中,通过\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.prototype.toString 方法，判断某个对象值属于哪种内置类型。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在介绍 Object.prototype.toString 方法之前，我们先把 toString()方法和\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.prototype.toString.call()方法进行对比。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\">• <spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">toString()方法和 Object.prototype.toString.call()方法对比</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:symbol;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (76, 'js 变量按照存储方式区分为哪些类型，并描述其特点？', 1, '2023-02-09 13:27:38', 0, '1、值类型和引用类型。\n2、值类型存储的是值 ，赋值之后原变量的值不改变 。\n3、引用类型存储的是地址 ，赋值之后是把原变量的引用地址赋值给新变量 ，新变量改变原来\n的会跟着改变', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1、值类型和引用类型。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、值类型存储的是值 ，赋值之后原变量的值不改变 。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3、引用类型存储的是地址 ，赋值之后是把原变量的引用地址赋值给新变量 ，新变量改变原来\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">的会跟着改变</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (77, '如何实现数组的随机排序？', 1, '2023-02-09 13:28:25', 0, '如何实现数组的随机排序？', 21, '<pre><code>方法一：\n var arr = [1,2,3,4,5,6,7,8,9,10];\n function randSort1(arr){\n for(var i = 0,len = arr.length;i &lt; len; i++ ){\n var rand = parseInt(Math.random()*len);\n var temp = arr[rand];\n arr[rand] = arr[i];\n arr[i] = temp;\n }\n return arr;\n }\n console.log(randSort1(arr));</code></pre><pre><code>方法二：\nvar arr = [1,2,3,4,5,6,7,8,9,10];\n function randSort2(arr){\n var mixedArray = [];\n while(arr.length &gt; 0){\n var randomIndex = parseInt(Math.random()*arr.length);\n mixedArray.push(arr[randomIndex]);\n arr.splice(randomIndex, 1);\n }\n return mixedArray;\n }\n console.log(randSort2(arr));</code></pre><pre><code>方法三：\nvar arr = [1,2,3,4,5,6,7,8,9,10];\n arr.sort(function(){ \n    return Math.random() - 0.5;\n })\n console.log(arr);</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (78, 'Function foo() {}和 var foo = function() {}之间 foo 的用 法上的区别？', 1, '2023-02-09 13:29:24', 0, 'Function foo() {}和 var foo = function() {}之间 foo 的用 法上的区别？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1.var foo = function () {}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">这种方式是声明了个变量，而这个变量是个方法，变量在 js 中是可以改变的。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2.function foo() {}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">这种方式是声明了个方法，foo 这个名字无法改变</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (79, '根据你的理解,请简述 JavaScript 脚本的执行原理', 1, '2023-02-09 13:29:49', 0, 'JavaScript 是一种动态、弱类型、基于原型的语言，通过浏览器可以直接执行。\n当浏览器遇到\\<script> 标记的时候，浏览器会执行之间的 javascript 代码。嵌入的 js 代码是顺\n序执行的，每个脚本定义的全局变量和函数，都可以被后面执行的脚本所调用。 变量的调用，\n必须是前面已经声明，否则获取的变量值是 undefined', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">JavaScript 是一种动态、弱类型、基于原型的语言，通过浏览器可以直接执行。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">当浏览器遇到\\&lt;script&gt; 标记的时候，浏览器会执行之间的 javascript 代码。嵌入的 js 代码是顺\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">序执行的，每个脚本定义的全局变量和函数，都可以被后面执行的脚本所调用。 变量的调用，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">必须是前面已经声明，否则获取的变量值是 undefined。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (80, '什么是 dom？', 1, '2023-02-09 13:30:55', 0, 'DOM 是 W3C（万维网联盟）的标准。\nDOM 定义了访问 HTML 和 XML 文档的标准：\n“W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问\n和更新文档的内容、结构和样式。”\nW3C DOM 标准被分为 3 个不同的部分：\n核心 DOM - 针对任何结构化文档的标准模型\nXML DOM - 针对 XML 文档的标准模型\nHTML DOM - 针对 HTML 文档的标准模型\n备注：DOM 是 Document Object Model（文档对象模型）的缩写。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">DOM 是 W3C（万维网联盟）的标准。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">DOM 定义了访问 HTML 和 XML 文档的标准：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">“W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">和更新文档的内容、结构和样式。”\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">W3C DOM 标准被分为 3 个不同的部分：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">核心 DOM - 针对任何结构化文档的标准模型\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">XML DOM - 针对 XML 文档的标准模型\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">HTML DOM - 针对 HTML 文档的标准模型\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">备注：DOM 是 Document Object Model（文档对象模型）的缩写。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (81, 'dom 是哪种基本的数据结构？', 1, '2023-02-09 13:31:12', 0, 'DOM 是一种树形结构的数据结构', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">DOM 是一种树形结构的数据结构</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (82, 'dom 操作的常用 api 有哪些？', 1, '2023-02-09 13:31:51', 0, 'dom 操作的常用 api 有哪些？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1、获取 dom 节点\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">document.getElementById(\'div1\');\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">document.getElementsByTagName(\'div\');\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">document.getElementsByClassName(\'container\');\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">document.querySelector(\'p\');\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">document.querySelectorAll(\'p\');</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、property（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">js 对象的 property）</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">var p = document.getElementByTagName(\'p\')[0];\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">console.log(p.nodeName); // nodeName 是 p 的 property，即 nodeName 是 p 的属性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3、attribute\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">p.getAttribute(\'data-name\');\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">p.setAttribute(\'data-name\', \'imooc\');</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (83, 'dom 节点的 attribute 和 property 有何区别？', 1, '2023-02-09 13:32:19', 4, '每 个 DOM 节点都是一个 object 对象，它可以像其他的 js Object 一样具有自己的 property 和\nmethod，所以 property 的值可以是任何数据类型，大小写敏感，原则上 property 应该仅供 js\n操作，不会出现在 html 中（默认属性除外：id/src/href/className/dir/title/lang 等），和其他\njs object 一样，自定义的 property 也会出现在 object 的 for…in 遍历中', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1. Property\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">每 个 DOM 节点都是一个 object 对象，它可以像其他的 js Object 一样具有自己的 property 和\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">method，所以 property 的值可以是任何数据类型，大小写敏感，原则上 property 应该仅供 js\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">操作，不会出现在 html 中（默认属性除外：id/src/href/className/dir/title/lang 等），和其他\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">js object 一样，自定义的 property 也会出现在 object 的 for…in 遍历中\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2. Attribute\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">attribute 出现 在 dom 中，js 提供了 getAttribute/setAttribute 等方法来获取和改变它的值，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">attribute 的值只能是字符串且大小写不敏感，最后作用于 html 中，可以影响 innerHTML 获取\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">的值。可以通过访问 dom 节点的 attributes 属性来获取 改节点的所有的 attribute。（在 IE&lt;9\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">中,attribute 获取和改变的实际上是 property。）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3.自定义的 Property 与 Attribute 不同步,不相等\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">4.非自定义的 DOM property 与 attributes 是有条件同步的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">非自定义的属性(id/src/href/name/value 等)，通过 setAttribute 修改其特性值可以同步作用到\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">property 上，而通过.property 修改属性值有的(value)时候不会同步到 attribute 上，即不会反应\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">到 html 上(除以下几种情况，非自定义属性 在二者之间是同步的)。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (84, 'dom 结构操作怎样添加、移除、移动、复制、创建和查 找节点？', 1, '2023-02-09 13:32:59', 0, 'dom 结构操作怎样添加、移除、移动、复制、创建和查\n找节点？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1、创建新节点\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">createDocumentFragment() //创建一个 DOM 片段\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">createElement() //创建一个具体的元素\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">createTextNode() //创建一个文本节点\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、添加、移除、替换、插入\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">appendChild()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">removeChild()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">replaceChild()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">insertBefore() //并没有 insertAfter()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3、查找\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">getElementsByTagName() //通过标签名称</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">getElementsByName() //通过元素的 Name 属性的值(IE 容错能力较强，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">会得到一个数组，其中包括 id 等于 name 值的)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">getElementById() //通过元素 Id，唯一性</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (85, 'dom 事件的级别？', 1, '2023-02-09 13:33:24', 0, 'DOM 级别一共可以分为四个级别：DOM0 级、DOM1 级、DOM2 级和 DOM3 级。\n而 DOM 事件分为 3 个级别：DOM 0 级事件处理，DOM 2 级事件处理和 DOM 3 级事件处理。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">DOM 级别一共可以分为四个级别：DOM0 级、DOM1 级、DOM2 级和 DOM3 级。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">而 DOM 事件分为 3 个级别：DOM 0 级事件处理，DOM 2 级事件处理和 DOM 3 级事件处理。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">由于 DOM 1 级中没有事件的相关内容，所以没有 DOM 1 级事件\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1、dom0 element.οnclick=function(){}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、dom2 element.addEventListener(‘click’, function(){}, false) // 默认是 false。false：冒泡阶\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">段执行，true：捕获阶段产生。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3、dom3 element.addEventListener(‘keyup’, function(){}, false) // 事件类型增加了很多，鼠\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">标事件、键盘事件\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">UI 事件，当用户与页面上的元素交互时触发，如：load、scroll\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">焦点事件，当元素获得或失去焦点时触发，如：blur、focus\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">鼠标事件，当用户通过鼠标在页面执行操作时触发如：dblclick、mouseup\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">文本事件，当在文档中输入文本时触发，如：textInput\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">合成事件，当为 IME（输入法编辑器）输入字符时触发，如：compositionstart\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">变动事件，当底层 DOM 结构发生变化时触发，如：DOMsubtreeModified\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">同时 DOM3 级事件也允许使用者自定义一些事件</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (86, 'dom 事件模型？', 1, '2023-02-09 13:33:46', 0, 'DOM 事件模型。DOM 事件模型分为两种：事件捕获和事件冒泡。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">DOM 事件模型。DOM 事件模型分为两种：事件捕获和事件冒泡。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">事件捕获以点击事件为例，同类型事件会由根元素开始触发，向内传播，一直到目标元素。从\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">外到内依次触发：根—目标的祖先素—目标的父元素—目标元素\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">事件冒泡和事件捕获截然相反。发生点击事件时，事件会从目标元素上开始触发，向外传播，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">一直到根元素停止。从内到外依次触发：目标元素—目标元素的父元素—父元素的父元素—根\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">事件传播\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">事件捕获和事件冒泡都有事件传播阶段，传播阶段就是事件从触发开始到结束的过程。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">优先级：先捕获，再冒泡。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">两种传播方式的来源：W3C 推行 DOM2 级事件之前网景和 IE 在打架，网景用的事件传播方式\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">是捕获，IE 用的事件传播方式是冒泡</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (87, 'dom 事件流', 1, '2023-02-09 13:34:05', 0, '1）事件捕获阶段：事件传播由目标节点的祖先节点逐级传播到目标节点。先由文档的根节点\ndocument（window）开始触发对象，最后传播到目标节点，从外向内捕获事件对象\n2）处于目标阶段：事件到达目标对象，事件触发，如果事件不允许冒泡，事件会在这一阶段停\n止传播\n3）事件冒泡阶段：从目标节点逐级传播到 document 节点', 21, '<p>​<span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">1）事件捕获阶段：事件传播由目标节点的祖先节点逐级传播到目标节点。先由文档的根节点</span><br></p><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">document（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">window）开始触发对象，最后传播到目标节点，从外向内捕获事件对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2）处于目标阶段：事件到达目标对象，事件触发，如果事件不允许冒泡，事件会在这一阶段停\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">止传播\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3）事件冒泡阶段：从目标节点逐级传播到 document 节点</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (88, '什么是事件冒泡，它是如何工作的？如何阻止事件冒 泡?', 1, '2023-02-09 13:34:17', 0, '什么是事件冒泡，它是如何工作的？如何阻止事件冒\n泡?', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在一个对象上触发某类事件（比如单击 onclick 事件），如果此对象定义了此事件的处理程序，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回 true，那么这\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">被激活），或者它到达了对象层次的最顶层，即 document 对象（有些浏览器是 window）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">阻止事件冒泡的几种方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">第一种：event.stopPropagation();\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">第二种：return false;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">第三种：event.preventDefault()</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (89, 'JS 动画和 CSS3 动画有什么区别？', 1, '2023-02-09 13:34:43', 0, 'JS 动画和 CSS3 动画有什么区别？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">CSS 动画\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">优点：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(1)浏览器可以对动画进行优化。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、 浏览器使用与 requestAnimationFrame 类似的机制，requestAnimationFrame 比起\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">setTimeout，setInterval 设置动画的优势主要是:1)requestAnimationFrame 会把每一帧中的所有\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">DOM 操作集中起来，在一次重绘或回流中就完成,并且重绘或回流的时间间隔紧紧跟随浏览器\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的刷新频率,一般来说,这个频率为每秒 60 帧。2)在隐藏或不可见的元素中\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">requestAnimationFrame 不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">量。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、强制使用硬件加速 （通过 GPU 来提高动画性能）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(2)代码相对简单,性能调优方向固定\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(3)对于帧速表现不好的低版本浏览器，CSS3 可以做到自然降级，而 JS 则需要撰写额外代码\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">缺点：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、 运行过程控制较弱,无法附加事件绑定回调函数。CSS 动画只能暂停,不能在动画中寻找一个\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">是绑定回放事件,无进度报告。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、 代码冗长。想用 CSS 实现稍微复杂一点动画,最后 CSS 代码都会变得非常笨重。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JS 动画\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">优点：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(1)JavaScript 动画控制能力很强, 可以在动画播放过程中对动画进行控制：开始、暂停、回放、\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">终止、取消都是可以做到的。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(2)动画效果比 css3 动画丰富,有些动画效果，比如曲线运动,冲击闪烁,视差滚动效果，只有\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JavaScript 动画才能完成。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(3)CSS3 有兼容性问题，而 JS 大多时候没有兼容性问题。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">缺点：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(1)JavaScript 在浏览器的主线程中运行，而主线程中还有其它需要运行的 JavaScript 脚本、样式\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">计算、布局、绘制任务等,对其干扰导致线程可能出现阻塞，从而造成丢帧的情况。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(2)代码的复杂度高于 CSS 动画\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">总结：如果动画只是简单的状态切换，不需要中间过程控制，在这种情况下，css 动画是优选方\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥 Javascript 库。然而如\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">果你在设计很复杂的富客户端界面或者在开发一个有着复杂 UI 状态的 APP。那么你应该使用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">js 动画，这样你的动画可以保持高效，并且你的工作流也更可控。所以，在实现一些小的交互\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">动效的时候，就多考虑考虑 CSS 动画。对于一些复杂控制的动画，使用 javascript 比较可靠。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">css 动画和 js 动画的差异\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1. 代码复杂度，js 动画代码相对复杂一些 。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2. 动画运行时，对动画的控制程度上，js 能够让动画，暂停，取消，终止，css 动画不能添加\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">事件。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3. 动画性能看，js 动画多了一个 js 解析的过程，性能不如 css 动画好。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (90, 'event 对象的常见应用？', 1, '2023-02-09 13:34:58', 0, '1、event.preventDefault(); // 阻止默认行为，阻止 a 链接默认的跳转行为\n2、event.stopPropagation(); // 阻止冒泡\n3、event.stopImmediatePropagation(); // 按钮绑定了 2 个响应函数，依次注册 a,b 两个事件，\n点击按钮，a 事件中加 event.stopImmediatePropagation()就能阻止 b 事件\n4、event.currentTarget // 早期的 ie 不支持，当前绑定的事件', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1、event.preventDefault(); // 阻止默认行为，阻止 a 链接默认的跳转行为\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、event.stopPropagation(); // 阻止冒泡\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3、event.stopImmediatePropagation(); // 按钮绑定了 2 个响应函数，依次注册 a,b 两个事件，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">点击按钮，a 事件中加 event.stopImmediatePropagation()就能阻止 b 事件\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">4、event.currentTarget // 早期的 ie 不支持，当前绑定的事件</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (91, '自定义事件/ 模拟事件？', 1, '2023-02-09 13:35:40', 0, '自定义事件/ 模拟事件？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1、给一个按钮自己增加一个事件，在其他地方触发，而不是用回调的方式触发</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><pre><code>var ev = document.getElementById(\'ev\');\nvar eve = new Event(\'custome\'); // eve：事件对象\nev.addEventListener(\'custome\', function(){\nconsole.log(\'custome\');\n});\nev.dispatchEvent(eve);</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、customeEvent</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (92, '通用事件绑定/ 编写一个通用的事件监听函数？（必 会）', 1, '2023-02-09 13:36:04', 0, '通用事件绑定/ 编写一个通用的事件监听函数？（必\n会）', 21, '<pre><code>function bindEvent(elem, type, selector, fn) {\nif (fn == null) {\nfn = selector;\nselector = null;\n}\nelem.addEventListner(type, function(e) {\nvar target;\nif (selector) {\ntarget = e.target;\nif (target.matches(selector)) {\nfn.call(target, e);\n}\n} else {\nfn(e);\n}\n})\n}\n// 使用代理\nvar div1 = document.getElementById(\'div1\');\nbindEvent(div1, \'click\', \'a\', function(e) {\nconsole.log(this.innerHTML);\n});\n// 不使用代理\nvar a = document.getElementById(\'a1\');\nbindEvent(div1, \'click\', function(e) {\nconsole.log(a.innerHTML);\n})</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1、代理的好处\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1）代码简洁\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2）减少浏览器内存占用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、事件冒泡\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">事件冒泡的应用：代理</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (93, 'dom 和 bom 的区别', 1, '2023-02-09 13:37:01', 0, 'BOM\n1. BOM 是 Browser Object Model 的缩写，即浏览器对象模型。\n2. BOM 没有相关标准。\n3. BOM 的最根本对象是 window\nDOM\n1. DOM 是 Document Object Model 的缩写，即文档对象模型。\n2. DOM 是 W3C 的标准。\n3. DOM 最根本对象是 document（实际上是 window.document）', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">BOM\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1. BOM 是 Browser Object Model 的缩写，即浏览器对象模型。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2. BOM 没有相关标准。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3. BOM 的最根本对象是 window\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">DOM\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1. DOM 是 Document Object Model 的缩写，即文档对象模型。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2. DOM 是 W3C 的标准。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3. DOM 最根本对象是 document（实际上是 window.document）</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (94, '事件三要素', 1, '2023-02-09 13:37:30', 0, '（1）事件源、就是你点的那个 div，触发的对象\n（2）事件、表示动作，比如点击、滑过等\n（3）事件处理函数、表示结果，比如点开关跳转到另一个页面', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">1）事件源、就是你点的那个 div，触发的对象</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">2）事件、表示动作，比如点击、滑过等</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">3）事件处理函数、表示结果，比如点开关跳转到另一个页面</span></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (95, '事件执行过程', 1, '2023-02-09 13:37:47', 0, '事件捕获过程：当我们点击 TEXT 时，首先是 window->document->body->div->text.这个过程\n称为事件捕获，W3C 浏览器的标准执行流程。\n事件冒泡过程：text->div->body->document->window.这个过程称为事件冒泡。IE 浏览器只\n支持冒泡，不支持捕获。W3C 浏览器先执行捕获，后执行冒泡', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">事件捕获过程：当我们点击 TEXT 时，首先是 window-&gt;document-&gt;body-&gt;div-&gt;text.这个过程\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">称为事件捕获，W3C 浏览器的标准执行流程。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">事件冒泡过程：text-&gt;div-&gt;body-&gt;document-&gt;window.这个过程称为事件冒泡。IE 浏览器只\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">支持冒泡，不支持捕获。W3C 浏览器先执行捕获，后执行冒泡</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (96, '获取元素位置', 1, '2023-02-09 13:58:04', 0, '获取元素位置获取元素位置获取元素位置获取元素位置获取元素位置', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1.通过元素的 offsetLeft 和 offsetTop\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">dom 元素的 offsetLeft、offsetTop 指的是元素相对于其 offseParent 指定的坐标来说的。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">offsetParent：是指当前元素最近的经过定位的父级元素，如果没有则一直向上直至 body。注\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">意当前元素为 fixed 时，其 offsetParent 的值为 null\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">拓展：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">offsetWidth/offsetHeight: width+padding+border\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">clientLeft/clientTop:表示内容区域的左上角相对于整个元素左上角的位置（包括边框）//个人理\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">解为 border 值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">clientWidth/clientHeight: width+padding\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">scrollWidth:获取对象的滚动宽度\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">scrollHeight: 获取对象的滚动高度。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">window.screen.availHeight/window.screen.availWidth: 浏览器去除上方工具栏和下放菜单栏可用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">宽高\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">window.screen.height/window.screen.width: 屏幕宽高\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2.event.clientX 和 event.clientY\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">事件相对于文档的水平和垂直距离\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3.getBoundingClientRect\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">方法返回一个一个矩形对象，包含四个属性：left、top、right 和 bottom。分别表示元素各边与\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">页面上边和左边的距离。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (97, '谈谈事件委托的理解？', 1, '2023-02-09 14:02:17', 0, 'JavaScript 事件代理则是一种简单的技巧，通过它你可以把事件处理器添加到一个上级元素上，\n这样就避免了把事件处理器添加到多个子级元素上。当我们需要对很多元素添加事件的时候，\n可以通过将事件添加到它们的上级元素而将事件委托给上级元素来触发处理函数。这主要得益\n于浏览器的事件冒泡机制。事件代理用到了两个在 JavaSciprt 事件中常被忽略的特性：事件冒\n泡以及目标元素。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JavaScript 事件代理则是一种简单的技巧，通过它你可以把事件处理器添加到一个上级元素上，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">这样就避免了把事件处理器添加到多个子级元素上。当我们需要对很多元素添加事件的时候，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">可以通过将事件添加到它们的上级元素而将事件委托给上级元素来触发处理函数。这主要得益\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">于浏览器的事件冒泡机制。事件代理用到了两个在 JavaSciprt 事件中常被忽略的特性：事件冒\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">泡以及目标元素。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">优点：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1.减少事件注册，节省内存。比如，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2.在 table 上代理所有 td 的 click 事件。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3.在 ul 上代理所有 li 的 click 事件。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">4.简化了 dom 节点更新时，相应事件的更新。比如\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">5.不用在新添加的 li 上绑定 click 事件。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">6.当删除某个 li 时，不用移解绑上面的 click 事件。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">缺点：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1.事件委托基于冒泡，对于不冒泡的事件不支持。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2.层级过多，冒泡过程中，可能会被某层阻止掉。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3.理论上委托会导致浏览器频繁调用处理函数，虽然很可能不需要处理。所以建议就近委托，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">比如在 table 上代理 td，而不是在 document 上代理 td。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">4.把所有事件都用代理就可能会出现事件误判。比如，在 document 中代理了所有 button 的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">click 事件，另外的人在引用改 js 时，可能不知道，造成单击 button 触发了两个 click 事件</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (98, 'JavaScript 中的定时器有哪些？他们的区别及用法是什 么？', 1, '2023-02-09 14:02:35', 0, '1、setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。2、setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。\nsetInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由\nsetInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。<br><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。由\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">setInterval() 返回的 ID 值可用作 clearInterval() 方法的参数。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (99, 'Document.write 和 innerHTML 的区别？', 1, '2023-02-09 14:03:07', 0, 'document.write 是直接写入到页面的内容流，如果在写之前没有调用 document.open, 浏览器\n会自动调用 open。每次写完关闭之后重新调用该函数，会导致页面被重写。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">document.write 是直接写入到页面的内容流，如果在写之前没有调用 document.open, 浏览器\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">会自动调用 open。每次写完关闭之后重新调用该函数，会导致页面被重写。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">innerHTML 则是 DOM 页面元素的一个属性，代表该元素的 html 内容。你可以精确到某一个具\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">体的元素来进行更改。如果想修改 document 的内容，则需要修改\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">document.documentElement.innerElement。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">innerHTML 将内容写入某个 DOM 节点，不会导致页面全部重绘\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">innerHTML 很多情况下都优于 document.write，其原因在于其允许更精确的控制要刷新页面的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">那一个部分。&nbsp;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (100, '什么是 window 对象？什么是 document 对象？', 1, '2023-02-09 14:03:50', 0, '简单来说，document 是 window 的一个对象属性。\nWindow 对象表示浏览器中打开的窗口。\n如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对\n象，并为每个框架创建一个额外的 window 对象。\n所有的全局函数和对象都属于 Window 对象的属性和方法。\ndocument 对 Document 对象的只读引用。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">简单来说，document 是 window 的一个对象属性。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Window 对象表示浏览器中打开的窗口。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">象，并为每个框架创建一个额外的 window 对象。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">所有的全局函数和对象都属于 Window 对象的属性和方法。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">document 对 Document 对象的只读引用。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">[window 对象]\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">它是一个顶层对象,而不是另一个对象的属性，即浏览器的窗口。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">属性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">defaultStatus 缺省的状态条消息\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">document 当前显示的文档(该属性本身也是一个对象)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">frame 窗口里的一个框架((FRAME&gt;)(该属性本身也是一个对象)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">frames array 列举窗口的框架对象的数组,按照这些对象在文档中出现的顺序列出(该属性本身也\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">是一个对象)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">history 窗口的历史列表(该属性本身也是一个对象)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">length 窗口内的框架数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">location 窗口所显示文档的完整(绝对)URL(该属性本身也是一个对象)不要把它与如\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">document.location 混淆,后者是当前显示文档的 URL。用户可以改变 window.location(用另一个\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">文档取代当前文档),但却不能改变 document.location (因为这是当前显示文档的位置)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">name 窗口打开时,赋予该窗口的名字\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">opener 代表使用 window.open 打开当前窗口的脚本所在的窗口(这是 Netscape Navigator \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3.0beta 3 所引入的一个新属性)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">parent 包含当前框架的窗口的同义词。frame 和 window 对象的一个属性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">self 当前窗口或框架的同义词\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">status 状态条中的消息\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">top 包含当前框架的最顶层浏览器窗口的同义词\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">window 当前窗口或框架的同义词,与 self 相同\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">alert() 打开一个 Alert 消息框\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">clearTimeout() 用来终止 setTimeout 方法的工作</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">close() 关闭窗口\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">confirm() 打开一个 Confirm 消息框,用户可以选择 OK 或 Cancel,如果用户单击 OK,该方法返回\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">true,单击 Cancel 返回 false\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">blur() 把焦点从指定窗口移开(这是 Netscape Navigator 3.0 beta 3 引入的新方法)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">focus() 把指定的窗口带到前台(另一个新方法)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">open() 打开一个新窗口\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">prompt() 打开一个 Prompt 对话框,用户可向该框键入文本,并把键入的文本返回到脚本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">setTimeout() 等待一段指定的毫秒数时间,然后运行指令事件处理程序事件处理程序\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Onload() 页面载入时触发\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Onunload() 页面关闭时触发\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">[document 对象]\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">该对象是 window 和 frames 对象的一个属性,是显示于窗口或框架内的一个文档。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">属性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">alinkColor 活动链接的颜色(ALINK)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">anchor 一个 HTMI 锚点,使用&lt;A NAME=&gt;标记创建(该属性本身也是一个对象)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">anchors array 列出文档锚点对象的数组(&lt;A NAME=&gt;)(该属性本身也是一个对象)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">bgColor 文档的背景颜色(BGCOLOR)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">cookie 存储于 cookie.txt 文件内的一段信息,它是该文档对象的一个属性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">fgColor 文档的文本颜色(&lt;BODY&gt;标记里的 TEXT 特性)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">form 文档中的一个窗体(&lt;FORM&gt;)(该属性本身也是一个对象)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">forms anay 按照其出现在文档中的顺序列出窗体对象的一个数组(该属性本身也是一个对象)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">lastModified 文档最后的修改日期\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">linkColor 文档的链接的颜色,即&lt;BODY&gt;标记中的 LINK 特性(链接到用户没有观察到的文档)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">link 文档中的一个&lt;A HREF=&gt;标记(该属性本身也是一个对象)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">links array 文档中 link 对象的一个数组,按照它们出现在文档中的顺序排列(该属性本身也是一个\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">对象)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">location 当前显示文档的 URL。用户不能改变 document.location(因为这是当前显示文档的位\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">置)。但是,可以改变 window.location (用其它文档取代当前文档)window.location 本身也是一个\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">对象,而 document.location 不是对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">referrer 包含链接的文档的 URL,用户单击该链接可到达当前文档\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">title 文档的标题((TITLE&gt;)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">vlinkColor 指向用户已观察过的文档的链接文本颜色,即&lt;BODY&gt;标记的 VLINK 特性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">clear 清除指定文档的内容\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">close 关闭文档流\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">open 打开文档流\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">write 把文本写入文档\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">writeln 把文本写入文档,并以换行符结尾\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">区别:1、window 指窗体。document 指页面。document 是 window 的一个子对象。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、用户不能改变 document.location(因为这是当前显示文档的位置)。但是,可以改变\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">window.location (用其它文档取代当前文档)window.location 本身也是一个对象,而\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">document.location 不是对象</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (101, 'Js 拖动的原理？', 1, '2023-02-09 14:04:31', 0, 'js 的拖拽效果主要用到以下三个事件：\nmousedown 鼠标按下事件\nmousemove 鼠标移动事件\nmouseup 鼠标抬起事件\n当点击 dom 的时候，记录当前鼠标的坐标值，也就是 x、y 值，以及被拖拽的 dom 的 top、left\n值，而且还要在鼠标按下的回调函数里添加鼠标移动的事件：', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">js 的拖拽效果主要用到以下三个事件：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">mousedown 鼠标按下事件\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">mousemove 鼠标移动事件\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">mouseup 鼠标抬起事件\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当点击 dom 的时候，记录当前鼠标的坐标值，也就是 x、y 值，以及被拖拽的 dom 的 top、left\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">值，而且还要在鼠标按下的回调函数里添加鼠标移动的事件：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">document.addEventListener(\"mousemove\", moving, false)和添加鼠标抬起的事件\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">document.addEventListener(\"mouseup\",function()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">{ document.removeEventListener(\"mousemove\", moving, false);}, false);这个抬起的事件是为了解\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">除鼠标移动的监听，因为只有在鼠标按下才可以拖拽，抬起就停止不会移动了。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当鼠标按下鼠标移动的时候，记录移动中的 x、y 值，那么这个被拖拽的 dom 的 top 和 left 值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">就是：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">top=鼠标按下时记录的 dom 的 top 值+（移动中的 y 值 - 鼠标按下时的 y 值）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">left=鼠标按下时记录的 dom 的 left 值+（移动中的 x 值 - 鼠标按下时的 x 值）;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (102, '描述浏览器的渲染过程，DOM 树和渲染树的区别', 1, '2023-02-09 14:04:49', 0, '描述浏览器的渲染过程，DOM 树和渲染树的区别', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">浏览器的渲染过程：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">解析 HTML 构建 DOM(DOM 树)，并行请求 css/image/js\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">CSS 文件下载完成，开始构建 CSSOM(CSS 树)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">布局(Layout)：计算出每个节点在屏幕中的位置\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">显示(Painting)：通过显卡把页面画到屏幕上\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">DOM 树 和 渲染树 的区别：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">DOM 树与 HTML 标签一一对应，包括 head 和隐藏元素\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">渲染树不包括 head 和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">css 属性</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (103, 'dom 树和 render 树之间的关系？', 1, '2023-02-09 14:05:08', 0, '1、dom 树，css 树合并成成渲染树（render 树）\n2、DOM 树与 HTML 标签一一对应，包括 head 和隐藏元素\n3、渲染树不包括 head 和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应\n的 css 属性', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1、dom 树，css 树合并成成渲染树（render 树）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、DOM 树与 HTML 标签一一对应，包括 head 和隐藏元素\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3、渲染树不包括 head 和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">的 css 属性</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (104, '获取到页面中所有的 CheckBox 怎么做（不适用第三方 框架）？', 1, '2023-02-09 14:05:33', 0, '获取到页面中所有的 CheckBox 怎么做（不适用第三方\n框架）？', 21, '<pre><code>var domList = document.getElementsByTagName(‘input’);\nvar checkBoxList = [];\nvar len = domList.length;//缓存到局部变量\nwhile (len--) {//使用 while 的效率会比 for 循环更高\nif (domList[len].type == ‘checkbox’) {\n checkBoxList.push(domList[len]);\n}\n}</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (105, '简单说一下页面重绘和回流？', 1, '2023-02-09 14:05:49', 0, '回流：当 render tree 的一部分或全部的元素因改变了自身的宽高，布局，显示或隐藏，或者\n元素内部的文字结构发生变化 导致需要重新构建页面的时候，回流就产生了。\n重绘：当一个元素自身的宽高，布局，及显示或隐藏没有改变，而只是改变了元素的外观风格\n的时候，就会产生重绘。例如你改变了元素的 background-color....\n因此得出了一个结论：回流必定触发重绘，而重绘不一定触发回流。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">回流：当 render tree 的一部分或全部的元素因改变了自身的宽高，布局，显示或隐藏，或者\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">元素内部的文字结构发生变化 导致需要重新构建页面的时候，回流就产生了。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">重绘：当一个元素自身的宽高，布局，及显示或隐藏没有改变，而只是改变了元素的外观风格\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的时候，就会产生重绘。例如你改变了元素的 background-color....\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">因此得出了一个结论：回流必定触发重绘，而重绘不一定触发回流。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (106, '如何最小化重绘(repaint)和回流(reflow)', 1, '2023-02-09 14:06:18', 2, '需要要对元素进行复杂的操作时，可以先隐藏(display:\"none\")，操作完成后再显示\n需要创建多个 DOM 节点时，使用 DocumentFragment 创建完后一次性的加入 document\n缓存 Layout 属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流\n尽量避免用 table 布局（table 元素一旦触发回流就会导致 table 里所有的其它元素回流）\n避免使用 css 表达式(expression)，因为每次调用都会重新计算值（包括加载页面）', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">需要要对元素进行复杂的操作时，可以先隐藏(display:\"none\")，操作完成后再显示\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">需要创建多个 DOM 节点时，使用 DocumentFragment 创建完后一次性的加入 document\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">缓存 Layout 属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">尽量避免用 table 布局（table 元素一旦触发回流就会导致 table 里所有的其它元素回流）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">避免使用 css 表达式(expression)，因为每次调用都会重新计算值（包括加载页面）</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx&nbsp;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (107, 'Js 延迟加载的方式有哪些？', 1, '2023-02-09 14:07:27', 0, 'js 实现延迟加载的几种方法，js 的延迟加载有助与提高页面的加载速度\nJS 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。\nJS 延迟加载有助于提高页面加载速度。\n一般有以下几种方式：\ndefer 属性\nasync 属性\n动态创建 DOM 方式\n使用 jQuery 的 getScript 方法\n使用 setTimeout 延迟方法', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">js 实现延迟加载的几种方法，js 的延迟加载有助与提高页面的加载速度\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JS 延迟加载，也就是等页面加载完成之后再加载 JavaScript 文件。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JS 延迟加载有助于提高页面加载速度。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">一般有以下几种方式：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">defer 属性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">async 属性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">动态创建 DOM 方式\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用 jQuery 的 getScript 方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用 setTimeout 延迟方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">让 JS 最后加载\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1. defer 属性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">HTML 4.01 为&lt;script&gt;标签定义了 defer 属性。标签定义了 defer 属性元素中设置 defer 属性，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">等于告诉浏览器立即下载，但延迟执行标签定义了 defer 属性。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">用途：表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">毕之后再执行。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在&lt;script&gt;元素中设置 defer 属性，等于告诉浏览器立即下载，但延迟执行。&nbsp;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">说明：虽然&lt;script&gt;元素放在了&lt;head&gt;元素中，但包含的脚本将延迟浏览器遇到&lt;/html&gt;标签\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">后再执行。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">HTML5 规范要求脚本按照它们出现的先后顺序执行。在现实当中，延迟脚本并不一定会按照顺\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">序执行。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">defer 属性只适用于外部脚本文件。支持 HTML5 的实现会忽略嵌入脚本设置的 defer 属性。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2. async 属性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">HTML5 为&lt;script&gt;标签定义了 async 属性。与 defer 属性类似，都用于改变处理脚本的行为。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">同样，只适用于外部脚本文件。标签定义了 async 属性。与 defer 属性类似，都用于改变处理\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">脚本的行为。同样，只适用于外部脚本文件。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">目的：不让页面等待脚本下载和执行，从而异步加载页面其他内容。异步脚本一定会在页面\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">load 事件前执行。不能保证脚本会按顺序执行。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (108, 'typeof 和 instanceof 区别', 1, '2023-02-09 14:09:25', 0, 'typeof 和 instanceof 区别', 21, '<div><spanyes\';font-size:12pt;font-family:宋体;color:rgb(0,0,0);\"> </spanyes\';font-size:12pt;font-family:宋体;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">javascript 中，判断一个变量的类型可以用 typeof \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">(1)数字类型、typeof 返回的值是 number。比如说：typeof(1)，返回值是 number \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">(2)字符串类型，typeof 返回的值是 string。比如 typeof(“123”返回值时 string)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">(3)布尔类型，typeof 返回的值是 boolean。比如 typeof(true)返回值时 boolean \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">(4)对象、数组、null 返回的值是 object。比如 typeof(window)，typeof(document)，typeof(null)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">返回的值都是 object\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">(5)函数类型，返回的值是 function。比如：typeof(eval)，typeof(Date)返回的值都是 function。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">(6)不存在的变量、函数或者 undefined，将返回 undefined。比如：typeof(abc)、\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">typeof(undefined)都返回 undefined\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">在 javascript 中，instanceof 用于判断某个对象是否被另一个函数构造。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">都返回”object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">Instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">的是，instanceof 方法要求开发者明确地确认对象为某特定类型</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (109, 'js 使用 typeof 能得到的哪些类型？', 1, '2023-02-09 14:09:40', 0, 'js 使用 typeof 能得到的哪些类型？', 21, '<pre><code>typeof 只能区分值类型\ntypeof undefined // undefined\ntypeof null // object\ntypeof console.log // function\ntypeof NaN // number</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (110, '解释一下什么是回调函数，并提供一个简单的例子？', 1, '2023-02-09 14:10:15', 0, '软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调用、回调\n和异步调用。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">软件模块之间总是存在着一定的接口，从调用方式上，可以把他们分为三类：同步调用、回调\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">和异步调用。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">同步调用是一种阻塞式调用，调用方要等待对方执行完毕才 返回，它是一种单向调用；回调是\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">异步调用是一种类似消息或事件的机制，不过它的 调用方向刚好相反，接口的服务在收到某种\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口）。回调和异步调用的关系\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">非常紧密，通常我们使用回 调来实现异步消息的注册，通过异步调用来实现消息的通知。同步</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">调用是三者当中最简单的，而回调又常常是异步调用的基础，因此，下面我们着重讨论回调机</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">制在 不同软件架构中的实现。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">事件或条件进行响应</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (111, '什么是闭包？', 1, '2023-02-09 14:10:44', 0, '“闭包就是能够读取其他函数内部变量的函数。例如在 javascript 中，只有函数内部的子函数才\n能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将\n函数内部和函数外部连接起来的桥梁', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">“闭包就是能够读取其他函数内部变量的函数。例如在 javascript 中，只有函数内部的子函数才\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">函数内部和函数外部连接起来的桥梁。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">举例：创建闭包最常见方式，就是在一个函数内部创建另一个函数。下面例子中的 closure 就\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">是一个闭包，</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>function func(){ \nvar a =1 ,b = 2;\nfunciton closure(){ return a+b; } return\nclosure; }</code></pre><p><br></p></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (112, '什么是内存泄漏', 1, '2023-02-09 14:10:57', 0, '内存泄漏指任何对象在您不再拥有或需要它之后仍然存在', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (113, '哪些操作会造成内存泄漏？', 1, '2023-02-09 14:11:12', 0, '哪些操作会造成内存泄漏？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1、垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">存即可回收。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3、闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (114, 'js 内存泄漏的解决方式', 1, '2023-02-09 14:13:18', 0, 'js 内存泄漏的解决方式', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1、global variables：对未声明的变量的引用在全局对象内创建一个新变量。在浏览器中，全局\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">对象就是 window。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><pre><code>function foo(arg) {\nbar = \'some text\'; // 等同于 window.bar = \'some text\';\n}</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">1）解决：</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">①创建意外的全局变量</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><pre><code>function foo() {\nthis.var1 = \'potential accident\'\n}</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">②可以在 JavaScript 文件开头添加 “use strict”，使用严格模式。这样在严格模式下解析\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">JavaScript 可以防止意外的全局变量。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">③在使用完之后，对其赋值为 null 或者重新分配。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、被忘记的 Timers 或者 callbacks\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">在 JavaScript 中使用 setInterval 非常常见。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">大多数库都会提供观察者或者其它工具来处理回调函数，在他们自己的实例变为不可达时，会\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">让回调函数也变为不可达的。对于 setInterval，下面这样的代码是非常常见的</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><pre><code>var serverData = loadData();\nsetInterval(function() {\nvar renderer = document.getElementById(\'renderer\');\nif(renderer) {\nrenderer.innerHTML = JSON.stringify(serverData);\n}\n}, 5000); //This will be executed every ~5 seconds</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">这个例子阐述着 timers 可能发生的情况：计时器会引用不再需要的节点或数据\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3、闭包：一个可以访问外部（封闭）函数变量的内部函数。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">JavaScript 开发的一个关键方面就是闭包：一个可以访问外部（封闭）函数变量的内部函数。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">由于 JavaScript 运行时的实现细节，可以通过以下方式泄漏内存：&nbsp;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><pre><code>var theThing = null;\nvar replaceThing = function () {\n var originalThing = theThing;\nvar unused = function () {\n if (originalThing) // a reference to \'originalThing\'\n console.log(\"hi\");\n };\n theThing = {\n longStr: new Array(1000000).join(\'*\'),\n someMethod: function () {\n console.log(\"message\");\n }\n };\n};\nsetInterval(replaceThing, 1000);</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">4、DOM 引用</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">有时候，在数据结构中存储 DOM 结构是有用的。假设要快速更新表中的几行内容。将每行 DOM 的\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">引用存储在字典或数组中可能是有意义的。当这种情况发生时，就会保留同一 DOM 元素的两份引用：一\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">个在 DOM 树种，另一个在字典中。如果将来某个时候你决定要删除这些行，则需要让两个引用都不可达。</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>var elements = {\n button: document.getElementById(\'button\'),\n image: document.getElementById(\'image\')\n};\nfunction doStuff() {\n elements.image.src = \'http://example.com/image_name.png\';\n}\nfunction removeImage() {\n // The image is a direct child of the body element.\n document.body.removeChild(document.getElementById(\'image\'));\n // At this point, we still have a reference to #button in the\n //global elements object. In other words, the button element is\n //still in memory and cannot be collected by the GC.\n}</code></pre><p><br></p></spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (115, '说说你对原型（prototype）理解', 1, '2023-02-09 14:13:41', 0, 'JavaScript 是一种通过原型实现继承的语言与别的高级语言是有区别的，像 java，C#是通过类\n型决定继承关系的，JavaScript 是的动态的弱类型语言，总之可以认为 JavaScript 中所有都是对\n象，在 JavaScript 中，原型也是一个对象，通过原型可以实现对象的属性继承，JavaScript 的对\n象中都包含了一个” prototype”内部属性，这个属性所对应的就是该对象的原型。\n“prototype”作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原\n型，Firefox 和 Chrome 内核的 JavaScript 引擎中提供了”proto“这个非标准的访问器（ECMA\n新标准中引入了标准对象原型访问器”Object.getPrototype(object)”）。\n原型的主要作用就是为了实现继承与扩展对象。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">JavaScript 是一种通过原型实现继承的语言与别的高级语言是有区别的，像 java，C#是通过类\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">型决定继承关系的，JavaScript 是的动态的弱类型语言，总之可以认为 JavaScript 中所有都是对\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">象，在 JavaScript 中，原型也是一个对象，通过原型可以实现对象的属性继承，JavaScript 的对\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">象中都包含了一个” prototype”内部属性，这个属性所对应的就是该对象的原型。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">“prototype”作为对象的内部属性，是不能被直接访问的。所以为了方便查看一个对象的原\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">型，Firefox 和 Chrome 内核的 JavaScript 引擎中提供了”proto“这个非标准的访问器（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">ECMA\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">新标准中引入了标准对象原型访问器”Object.getPrototype(object)”）。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">原型的主要作用就是为了实现继承与扩展对象。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (116, '介绍下原型链（解决的是继承问题吗）?', 1, '2023-02-09 14:14:09', 0, 'JavaScript 原型： 每个对象都会在其内部初始化一个属性，就是 prototype(原型)。 原型链：\n当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去 prototype\n里找这个属性，这个 prototype 又会有自己的 prototype，于是就这样一直找下去，也就是我们\n平时所说的原型链的概念。', 21, '<div><spanyes\';font-size:16.08pt;font-family:等线;color:rgb(0,0,0);\">介绍</spanyes\';font-size:16.08pt;font-family:等线;color:rgb(0,0,0);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">JavaScript 原型：</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">每个对象都会在其内部初始化一个属性，就是 prototype(原型)。 原型链：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去 prototype\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">里找这个属性，这个 prototype 又会有自己的 prototype，于是就这样一直找下去，也就是我们\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">平时所说的原型链的概念。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">特点：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">JavaScript 对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">副本。当我们修改原型时，与之相关的对象也会继承这一改变。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (117, '简单说说 js 中的继承', 1, '2023-02-09 14:14:36', 0, '有以下六种方法\n1.原型链继承 JavaScript 实现继承的基本思想：通过原型将一个引用类型继承另一个引用类型\n的属性和方法。\n2.借用构造函数继承(伪造对象或经典继承) JavaScript 实现继承的基本思想：在子类构造函数内\n部调用超类型构造函数。 通过使用 apply()和 call()方法可以在新创建的子类对象上执行构造函\n数。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">有以下六种方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1.原型链继承 JavaScript 实现继承的基本思想：通过原型将一个引用类型继承另一个引用类型\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">的属性和方法。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2.借用构造函数继承(伪造对象或经典继承) JavaScript 实现继承的基本思想：在子类构造函数内\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">部调用超类型构造函数。 通过使用 apply()和 call()方法可以在新创建的子类对象上执行构造函\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">数。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3.组合继承(原型+借用构造)(伪经典继承) JavaScript 实现继承的基本思想：将原型链和借用构造</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">函数的技术组合在一块，从而发挥两者之长的一种继承模式。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">将原型链和借用构造函数的技术组合到一起，从而取长补短发挥两者长处的一种继承模式。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">4.原型式继承 JavaScript 实现继承的基本思想：借助原型可以基于已有的对象创建新对象，同\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">时还不必须因此创建自定义的类型。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">5.寄生式继承 JavaScript 实现继承的基本思想：创建一个仅用于封装继承过程的函数，该函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">在内部以某种方式来增强对象，最后再像真正是它做了所有工作一样返回对象。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">寄生式继承是原型式继承的加强版。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">6.寄生组合式继承 JavaScript 实现继承的基本思想：通过借用函数来继承属性，通过原型链的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">混成形式来继承方法</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (118, '介绍 this 各种情况', 1, '2023-02-09 14:14:54', 2, 'this 的情况：\n1.以函数形式调用时，this 永远都是 window\n2.以方法的形式调用时，this 是调用方法的对象\n3.以构造函数的形式调用时，this 是新创建的那个对象\n4.使用 call 和 apply 调用时，this 是指定的那个对象\n5.箭头函数：箭头函数的 this 看外层是否有函数\n 如果有，外层函数的 this 就是内部箭头函数的 this\n 如果没有，就是 window\n6.特殊情况：通常意义上 this 指针指向为最后调用它的对象。这里需要注意的一点就是如果返\n回值是一个对象，那么 this 指向的就是那个返回的对象，如果返回值不是一个对象那么 this 还\n是指向函数的实例', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">this 的情况：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1.以函数形式调用时，this 永远都是 window\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2.以方法的形式调用时，this 是调用方法的对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3.以构造函数的形式调用时，this 是新创建的那个对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">4.使用 call 和 apply 调用时，this 是指定的那个对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">5.箭头函数：箭头函数的 this 看外层是否有函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"> 如果有，外层函数的 this 就是内部箭头函数的 this\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"> 如果没有，就是 window\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">6.特殊情况：通常意义上 this 指针指向为最后调用它的对象。这里需要注意的一点就是如果返\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">回值是一个对象，那么 this 指向的就是那个返回的对象，如果返回值不是一个对象那么 this 还\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">是指向函数的实例</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/df3c311d-5b82-78c1-454e-02e8e9b60fe0');
INSERT INTO `article` VALUES (119, '数组中的 forEach 和 map 的区别？', 1, '2023-02-09 14:18:38', 0, '相同点 都是循环遍历数组中的每一项\nforEach 和 map 方法里每次执行匿名函数都支持 3 个参数，参数分别是 item（当前每一项），\nindex（索引值），arr（原数组）\n匿名函数中的 this 都是指向 window 只能遍历数组 都不会改变原数组 区别 map 方法\n1.map 方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。\n2.map 方法不会对空数组进行检测，map 方法不会改变原始数组。\n3.浏览器支持：chrome、Safari1.5+、opera 都支持，IE9+, 若 arr 为空数组，则 map 方法返回\n的也是一个空数组。 forEach 方法\n1.forEach 方法用来调用数组的每个元素，将元素传给回调函数\n2.forEach 对于空数组是不会调用回调函数的。 无论 arr 是不是空数组，forEach 返回的都是\nundefined。这个方法只是将数组中的每一项作为 callback 的参数执行一次', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">相同点 都是循环遍历数组中的每一项\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">forEach 和 map 方法里每次执行匿名函数都支持 3 个参数，参数分别是 item（当前每一项），\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">index（索引值），arr（原数组）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">匿名函数中的 this 都是指向 window 只能遍历数组 都不会改变原数组 区别 map 方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1.map 方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2.map 方法不会对空数组进行检测，map 方法不会改变原始数组。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3.浏览器支持：chrome、Safari1.5+、opera 都支持，IE9+, 若 arr 为空数组，则 map 方法返回\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">的也是一个空数组。 forEach 方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1.forEach 方法用来调用数组的每个元素，将元素传给回调函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2.forEach 对于空数组是不会调用回调函数的。 无论 arr 是不是空数组，forEach 返回的都是\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">undefined。这个方法只是将数组中的每一项作为 callback 的参数执行一次</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (120, 'for in 和 for of 的区别', 1, '2023-02-09 14:18:50', 0, '1.推荐在循环对象属性的时候使用 for...in，在遍历数组的时候的时候使用 for...of\n2.for...in 循环出的是 key，for...of 循环出的是 value\n3.注意，for...of 是 ES6 新引入的特性。修复了 ES5 引入的 for...in 的不足\n4.for...of 不能循环普通的对象，需要通过和 Object.keys()搭配使用', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1.推荐在循环对象属性的时候使用 for...in，在遍历数组的时候的时候使用 for...of\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2.for...in 循环出的是 key，for...of 循环出的是 value\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3.注意，for...of 是 ES6 新引入的特性。修复了 ES5 引入的 for...in 的不足\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">4.for...of 不能循环普通的对象，需要通过和 Object.keys()搭配使用</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (121, '常见的继承有几种方法', 1, '2023-02-09 14:19:36', 0, '（1）借用构造函数。也叫伪造对象或经典继承。（2）组合继承。也叫伪经典继承。指的是将原型链和借用构造函数的技术组合到一起，从而发挥二者之长。（3）原型链继承。（4）寄生式继承。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">1）借用构造函数。也叫伪造对象或经典继承。</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">思路：在子类构造函数的内部调用超类型构造函数。可以通过使用 apply()和 call()方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">在新创建的对象上执行构造函数。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">缺点：方法都在构造函数中定义，函数的复用就无从谈起。在超类型的原型中定义的方\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">法，对子类而言也是不可见的，结果所有的类型都只能使用构造函数模式。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">2）组合继承。也叫伪经典继承。指的是将原型链和借用构造函数的技术组合到一起，</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">从而发挥二者之长。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">思路：使用原型链实现对原型属性属性和方法的继承，通过借用构造函数来实现实例属\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">性的继承。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">优点：既通过在原型上定义方法实现了函数复用，又能保证每一个实例都有它自己的数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">组。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">组合继承避免了原型链和借用构造函数的缺陷，融合了他们的优点，成为 JavaScript \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">中常用的继承模式。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">3）原型链继承。</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">思路：借助原型可以基于已有的对象创建对象，同时还不必因此创建自定义类型。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">在 object()函数内部，先创建一个临时的构造函数，然后将传入的对象作为这个构造函\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">数的原型，最后返回了这个临时类型的一个新实例。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">4）寄生式继承。</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">思路：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">后再像真的是它做了所有的工作一样返回对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">缺点：使用寄生式继承来为对象添加函数，会由于不能做到函数复用二降低效率，这一\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">点和构造函数模式类似。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">5）寄生组合式继承。是 JavaScript 最常用的继承模式。</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">思路：通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">开发人员普遍认为寄生组合式继承时引用类型最理想的继承范式。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">extend（）方法才用了这样的方式。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (122, 'Call 和 apply，bind 的区别', 1, '2023-02-09 14:19:55', 0, 'call 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表)。\n注意：该方法的作用和 apply() 方法类似，只有一个区别，就是 call()方法接受的是若干个参数\n的列表，而 apply()方法接受的是一个包含多个参数的数组\n方法调用一个具有给定 this 值的函数，以及作为一个数组（或类似数组对象）提供的参数。\n注意：call()方法的作用和 apply() 方法类似，区别就是 call()方法接受的是参数列表，而 apply()\n方法接受的是一个参数数组。\nbind()方法创建一个新的函数，当这个新的函数被调用时，其 this 置为提供的值，其参数列表前\n几项，置为创建时指定的参数序列', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">call 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表)。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">注意：该方法的作用和 apply() 方法类似，只有一个区别，就是 call()方法接受的是若干个参数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">的列表，而 apply()方法接受的是一个包含多个参数的数组\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">方法调用一个具有给定 this 值的函数，以及作为一个数组（或类似数组对象）提供的参数。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">注意：call()方法的作用和 apply() 方法类似，区别就是 call()方法接受的是参数列表，而 apply()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">方法接受的是一个参数数组。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">bind()方法创建一个新的函数，当这个新的函数被调用时，其 this 置为提供的值，其参数列表前\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">几项，置为创建时指定的参数序列</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (123, 'New 操作符具体干了什么呢？', 1, '2023-02-09 14:20:13', 0, '1、创建一个空对象: 并且 this 变量引入该对象,同时还继承了函数的原型\n2、设置原型链 空对象指向构造函数的原型对象\n3、执行函数体 修改构造函数 this 指针指向空对象,并执行函数体\n4、判断返回值 返回对象就用该对象,没有的话就创建一个对象', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、创建一个空对象: 并且 this 变量引入该对象,同时还继承了函数的原型\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、设置原型链 空对象指向构造函数的原型对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、执行函数体 修改构造函数 this 指针指向空对象,并执行函数体\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4、判断返回值 返回对象就用该对象,没有的话就创建一个对象</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (124, '用 JavaScript 实现冒泡排序。数据为 23、45、18、 37、92、13、24 （必会）', 1, '2023-02-09 14:20:51', 0, '用 JavaScript 实现冒泡排序。数据为 23、45、18、 37、92、13、24 （必会）', 21, '<pre><code>//升序算法\nfunction sort(arr){ \nfor (var i = 0; i &lt;arr.length; i++) { \nfor (var j = 0; j &lt;arr.length-i; j++) { \nif(arr[j]&gt;arr[j+1]){ \nvar c=arr[j];//交换两个变量的位置\narr[j]=arr[j+1]; \narr[j+1]=c; \n} \n}; \n};\nreturn arr.toString(); \n}\nconsole.log(sort([23,45,18,37,92,13,24]));</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (125, '用 js 实现随机选取 10–100 之间的 10 个数字，存入一 个数组并排序', 1, '2023-02-09 14:21:03', 0, '用 js 实现随机选取 10–100 之间的 10 个数字，存入一\n个数组并排序', 21, '<div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">function randomNub(aArray, len, min, max) { \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">if (len &gt;= (max - min)) { \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">return \'超过\' + min + \'-\' + max + \'之间的个数范围\' + (max - min - 1) + \'个\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">的总数\'; \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">}\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">if (aArray.length &gt;= len) {\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">aArray.sort(function(a, b) { \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">return a - b \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">}); \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">return aArray; \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">}\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">var nowNub = parseInt(Math.random() * (max - min - 1)) + (min + 1); \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">for (var j = 0; j &lt; aArray.length; j++) { \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">if (nowNub == aArray[j]) { \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">randomNub(aArray, len, min, max); \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">return; \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">} \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">}\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">aArray.push(nowNub); \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">randomNub(aArray, len, min, max); \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">return aArray; \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">} \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">var arr=[]; \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">randomNub(arr,10,10,100);&nbsp;</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (126, '已知数组 var stringArray = [“This”,“is”, “Baidu”,“Campus”]， Alert 出”This is Baidu Campus”', 1, '2023-02-09 14:21:25', 0, '已知数组 var stringArray = [“This”,“is”, “Baidu”,“Campus”]，\nAlert 出”This is Baidu Campus”', 21, '<pre><code>var stringArray = [\"This\", \"is\", \"Baidu\", \"Campus\"] \nalert(stringArray.join(\"\"))</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (127, '已知有字符串 foo=”get-element-by-id”,写一个 function 将其转化成 驼峰表示法”getElementById', 1, '2023-02-09 14:21:51', 0, '已知有字符串 foo=”get-element-by-id”,写一个 function 将其转化成 驼峰表示法”getElementById', 21, '<pre><code>function combo(msg){ \nvar arr=msg.split(\"-\"); \nfor(var i=1;i&lt;arr.length;i++){ \narr[i]=arr[i].charAt(0).toUpperCase()+arr[i].substr(1,arr[i].length-1); \n}\nmsg=arr.join(\"\"); \nreturn msg; \n}</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (128, '有这样一个 URL： http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e，请 写一段 JS 程序提取 URL 中的各个 GET 参数(参数名和参数个数不确定)，将其按 keyvalue 形式返回到一个 json 结构中，如{a:’1′, b:’2′, c:”, d:’xxx’, e:undefined}（必 会）', 1, '2023-02-09 14:22:09', 0, '有这样一个 URL： http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e，请\n写一段 JS 程序提取 URL 中的各个 GET 参数(参数名和参数个数不确定)，将其按 keyvalue 形式返回到一个 json 结构中，如{a:’1′, b:’2′, c:”, d:’xxx’, e:undefined}（必\n会）', 21, '<pre><code>function serilizeUrl(url) { \nvar urlObject = {}; \nif (/\\?/.test(url)) { \nvar urlString = url.substring(url.indexOf(\"?\") + 1); \nvar urlArray = urlString.split(\"&amp;\"); \nfor (var i = 0, len = urlArray.length; i &lt; len; i++) { \nvar urlItem = urlArray[i]; \nvar item = urlItem.split(\"=\"); \nurlObject[item[0]] = item[1]; \n}\nreturn urlObject; \n}\nreturn null; \n}</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (129, '输出今天的日期，以 YYYY-MM-DD 的方式，比如今天是 2014 年 9 月 26 日，则输出 2014-09-26', 1, '2023-02-09 14:22:55', 0, '输出今天的日期，以 YYYY-MM-DD 的方式，比如今天是 2014 年 9 月 26 日，则输出 2014-09-26', 21, '<pre><code>var d = new Date(); \n// 获取年，getFullYear()返回 4 位的数字\nvar year = d.getFullYear(); \n// 获取月，月份比较特殊，0 是 1 月，11 是 12 月\nvar month = d.getMonth() + 1; \n// 变成两位\nmonth = month &lt; 10 ? \'0\' + month : month; \n// 获取日\nvar day = d.getDate(); \nday = day &lt; 10 ? \'0\' + day : day; \nalert(year + \'-\' + month + \'-\' + day);}</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (130, '把两个数组合并，并删除第二个元素', 1, '2023-02-09 14:23:40', 0, '把两个数组合并，并删除第二个元素', 21, '<div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">var array1 = [\'a\',\'b\',\'c\']; \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">var bArray = [\'d\',\'e\',\'f\']; \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">var cArray = array1.concat(bArray); \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">cArray.splice(1,1);</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (131, '写一个 function，清除字符串前后的空格。（兼容所 有浏览器）', 1, '2023-02-09 14:24:11', 0, '写一个 function，清除字符串前后的空格。（兼容所 有浏览器）', 21, '<div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">if (!String.prototype.trim) { \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">String.prototype.trim = function() { \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">return this.replace(/^\\s+/, \"\").replace(/\\s+$/,\"\");&nbsp;</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:12pt;font-family:宋体;color:rgb(0,0,0);\">\n</spanyes\';font-size:12pt;font-family:宋体;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">}\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">// test the function \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">var str = \" \\t\\n test string \".trim(); \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">alert(str == \"test string\"); // alerts \"true\"&nbsp;</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (132, '判断一个字符串中出现次数最多的字符，统计这个次 数', 1, '2023-02-09 14:24:29', 0, '判断一个字符串中出现次数最多的字符，统计这个次数', 21, '<pre><code>var str = \'asdfssaaasasasasaa\'; \nvar json = {}; \nfor (var i = 0; i &lt; str.length; i++) { \nif(!json[str.charAt(i)]){ \njson[str.charAt(i)] = 1; \n}else{ \njson[str.charAt(i)]++; \n} \n};\nvar iMax = 0; \nvar iIndex = \'\'; \nfor(var i in json){ \nif(json[i]&gt;iMax){ \niMax = json[i]; \niIndex = i; \n} \n}\nalert(\'出现次数最多的是:\'+iIndex+\'出现\'+iMax+\'次\');</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (133, '将数字 12345678 转化成 RMB 形式 如： 12,345,678', 1, '2023-02-09 14:25:05', 0, '将数字 12345678 转化成 RMB 形式 如： 12,345,678', 21, '<pre><code>//思路：先将数字转为字符， str= str + \'\' ; \n//利用反转函数，每三位字符加一个 \',\'最后一位不加；\n re()是自定义的反转函数，最后再反转回去！\nfor(var i = 1; i &lt;= re(str).length; i++){\ntmp += re(str)[i - 1]; \nif(i % 3 == 0 &amp;&amp; i != re(str).length){ \ntmp += \',\'; \n} \n}</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (134, 'Split（）和 join（）的区别？', 1, '2023-02-09 14:25:29', 0, 'Split（）和 join（）的区别？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Split()是把一串字符（根据某个分隔符）分成若干个元素存放在一个数组里\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">即切割成数组的形式；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">join() 是把数组中的字符串连成一个长串，可以大体上认为是 Split()的逆操作</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (135, 'JavaScript 中如何对一个对象进行深度 clone', 1, '2023-02-09 14:26:13', 0, 'JavaScript 中如何对一个对象进行深度 clone？（必 会）', 21, '<pre><code>&lt;!doctype html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=\"utf-8\"&gt;\n&lt;title&gt;深克隆&lt;/title&gt;\n&lt;script&gt;\nfunction clone(obj)\n{\nif(typeof obj==‘object‘)\n{\nif(obj instanceof Array)\n{\nvar result=[];\nfor(var i=0;i&lt;obj.length;i++)\n{\nresult[i]=clone(obj[i]);\n}\nreturn result;\n}\nelse\n{\nvar result={};\nfor(var i in obj)\n{\nresult[i]=clone(obj[i]);\n}\nreturn result;\n}\n}\nelse\n{\nreturn obj;\n}\n}\nvar obj1=[12, {a: 11, b: 22}, 5];\nvar obj2=clone(obj1);\nobj2[1].a+=5;\nconsole.log(obj1, obj2);\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (136, 'js 数组去重，能用几种方法实现', 1, '2023-02-09 14:26:35', 0, 'js 数组去重，能用几种方法实现', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1、使用 es6 set 方法 [...new Set(arr)] let arr = [1,2,3,4,3,2,3,4,6,7,6]; let unique = (arr)=&gt; [...new\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">Set(arr)]; unique(arr);//[1, 2, 3, 4, 6, 7]\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、利用新数组 indexOf 查找 indexOf() 方法可返回某个指定的元素在数组中首次出现的位置。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">如果没有就返回-1。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3、for 双重循环 通过判断第二层循环，去重的数组中是否含有该元素，如果有就退出第二层\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">循环，如果没有。 j==result.length 就相等，然后把对应的元素添加到最后的数组里面。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">let arr = [1,2,3,4,3,2,3,4,6,7,6]; let result = []; for(var i = 0 ; i\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">&lt; arr.length; i++) {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">for(var j = 0 ; j &lt; result.length ; j++) {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"> if( arr[i] === result[j]){\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"> break;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"> };\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">if(j == result.length){\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"> result.push(arr[i]);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">}; }; console.log(result);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">4.利用 for 嵌套 for，然后 splice 去重 functionunique(arr){ for(vari=0; i&lt;arr.length;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">i++){ for(varj=i+1; j&lt;arr.length; j++){ if(arr[i]==arr[j]){<br><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">//第一个等同于第二个，splice 方法删除第二个 arr.splice(j,1); j--; } } } returnarr; }\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">5.利用 filter let arr = [1,2,3,4,3,2,3,4,6,7,6]; let unique = (arr) =&gt; {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">return arr.filter((item,index) =&gt; {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"> return arr.indexOf(item) === index;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">}) }; unique(arr);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">5.let arr = [1,2,3,4,3,2,3,4,6,7,6]; let unique = (arr) =&gt; {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">return arr.filter((item,index) =&gt; {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"> return arr.indexOf(item) === index;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">}) }; unique(arr);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">6.利用 Map 数据结构去重 let arr = [1,2,3,4,3,2,3,4,6,7,6]; let unique = (arr)=&gt; {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">let seen = new Map();\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">return arr.filter((item) =&gt; {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"> return !seen.has(item) &amp;&amp; seen.set(item,1);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">}); }; unique(arr);</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (137, '谈谈你对 Javascript 垃圾回收机制的理解？', 1, '2023-02-09 14:26:51', 0, '谈谈你对 Javascript 垃圾回收机制的理解？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">(1)、标记清除（mark and sweep）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">这是 JavaScript 最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">为“离开环境”。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">(2)、引用计数(reference counting)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">在低版本 IE 中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">变量的时候这个值的引用次数就加 1，如果该变量的值变成了另外一个，则这个值得引用次数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">减 1，当这个值的引用次数变为 0 的时 候，说明没有变量在使用，这个值没法被访问了，因此\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的空\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">间。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">在 IE 中虽然 JavaScript 对象通过标记清除的方式进行垃圾回收，但 BOM 与 DOM 对象却是通过\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">引用计数回收垃圾的，也就是说只要涉及 BOM 及 DOM 就会出现循环引用问题。&nbsp;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (138, 'Class 和普通构造函数有何区别？', 1, '2023-02-09 14:27:40', 0, 'Class 和普通构造函数有何区别？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">Js 构造函数：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><pre><code>function MathHandle(x,y){\nthis.x=x\nthis.y=y\n}\nMathHandle.prototype.add=function(){\nReturn this.x+this.y\n}\nvar m =new MathHandle(1,2)\nconsole.log(m.add())\nclass 基本语法：\nclass MathHandle{\n constructor(x,y){\n this.x = x\n this.y = y\n }\n add(){\n return this.x + this.y\n }\n}\nconst m = new MathHandle(1,2)\nconsole.log(m.add())</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">语法糖：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">在上述两段代码中分别加入如下代码，运行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">console.log(typeof MathHandle) // \'function\'\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">console.log(MathHandle.prototype.constructor === MathHandle) //true\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">console.log(m.__proto__ === MathHandle.prototype) //true\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">运行结果一致。我认为，class 是构造函数的语法糖。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">综上所述：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">Class 在语法上更加贴合面向对象的写法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">Class 实现继承更加易读、易理解\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">更易于写 java 等后端语言的使用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">本质还是语法糖，使用 prototype</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (139, '什么是 js 事件循环 event loop', 1, '2023-02-09 14:27:56', 0, '主线程从\"任务队列\"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为\nEvent Loop（事件循环）', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">主线程从\"任务队列\"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">Event Loop（事件循环）</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (140, 'JS 里垃圾回收机制是什么，常用的是哪种，怎么处理 的？', 1, '2023-02-09 14:28:09', 0, 'JS 里垃圾回收机制是什么，常用的是哪种，怎么处理\n的？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">JS 的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">的内存。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">JS 中最常见的垃圾回收方式是标记清除。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">工作原理：是当变量进入环境时，将这个变量标记为“进入环境”。当变量离开环境时，则将\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">其标记为“离开环境”。标记“离开环境”的就回收内存。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">工作流程：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">去掉环境中的变量以及被环境中的变量引用的变量的标记。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">再被加上标记的会被视为准备删除的变量。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (141, '计算字符串字节数', 1, '2023-02-09 14:28:27', 0, '计算字符串字节数', 21, '<div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">new function(s){ \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">if(!arguments.length||!s) return null; \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">if(\"\"==s) return 0; \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">var l=0; \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">for(var i=0;i&lt;s.length;i++){ \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">if(s.charCodeAt(i)&gt;255) l+=2; else l+=1; //charCodeAt()得到的是 unCode 码\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">} //汉字的 unCode 码大于 255bit 就是两个字节\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">alert(l); \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">}(\"hello world!\");</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (142, 'Eval 是做什么的', 1, '2023-02-09 14:29:13', 0, '一、eval()的作用\n把字符串参数解析成 JS 代码并运行，并返回执行的结果；', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">一、eval()的作用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">把字符串参数解析成 JS 代码并运行，并返回执行的结果；</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">例如：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><pre><code>1、eval(\"2+3\");//执行加运算，并返回运算值。\n2、eval(\"varage=10\");//声明一个 age 变量</code></pre><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">注意事项\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">应该避免使用 eval，不安全，非常耗性能（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2 次，一次解析成 js 语句，一次执行）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在 IE8 及 IE8 一下的版本就不支持了。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">四、其它作用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">由 JSON 字符串转换为 JSON 对象的时候可以用 eval，例如：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、varjson=\"{name:\'Mr.CAO\',age:30}\";\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、varjsonObj=eval(\"(\"+json+\")\");\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、console.log(jsonObj);</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (143, '什么是进程、什么是线程、它们之间是什么关系', 1, '2023-02-09 14:29:36', 0, '什么是进程、什么是线程、它们之间是什么关系', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">进程：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1）程序执行时的一个实例\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2）每个进程都有独立的内存地址空间\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3）系统进行资源分配和调度的基本单位</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">4）进程里的堆，是一个进程中最大的一块内存，被进程中的所有线程共享的，进程创建时分\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">配，主要存放 new 创建的对象实例\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">5）进程里的方法区，是用来存放进程中的代码片段的，是线程共享的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">6）在多线程 OS 中，进程不是一个可执行的实体，即一个进程至少创建一个线程去执行代码\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">线程：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1）进程中的一个实体\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2）进程的一个执行路径\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3）CPU 调度和分派的基本单位\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">4）线程本身是不会独立存在\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">5）当前线程 CPU 时间片用完后，会让出 CPU 等下次轮到自己时候在执行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">6）系统不会为线程分配内存，线程组之间只能共享所属进程的资源\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">7）线程只拥有在运行中必不可少的资源(如程序计数器、栈)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">8）线程里的程序计数器就是为了记录该线程让出 CPU 时候的执行地址，待再次分配到时间片\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">时候就可以从自己私有的计数器指定地址继续执行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">9）每个线程有自己的栈资源，用于存储该线程的局部变量和调用栈帧，其它线程无权访问\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">关系：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1）一个程序至少一个进程，一个进程至少一个线程，进程中的多个线程是共享进程的资源\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2）Java 中当我们启动 main 函数时候就启动了一个 JVM 的进程，而 main 函数所在线程就\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">是这个进程中的一个线程，也叫做主线程\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3）一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程有自己的程序\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">计数器，栈区域</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (144, '什么是任务队列', 1, '2023-02-09 14:29:46', 2, '什么是任务队列', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">任务队列（task queue）主要分两种：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1、宏任务（macrotask）：在新标准中叫 task\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1)主要包括：script(整体代码)，setTimeout，setInterval，setImmediate，I/O，ui rendering\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、微任务（microtask）：在新标准中叫 jobs\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1）主要包括：process.nextTick， Promise，MutationObserver（html5 新特性）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">扩展：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1、同步任务：在主线程上，排队执行的任务，只有前一个任务执行完毕，才能执行后一个任\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">务;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、异步任务：不进入主线程，而进入“任务队列”（task queue）的任务，只有“任务队列”\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (145, '栈和队列的区别', 1, '2023-02-09 14:30:04', 0, '1、栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。\n2、队列先进先出，栈先进后出。', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1、栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2、队列先进先出，栈先进后出。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3、栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">删除#</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (146, 'es6 熟悉吗，es5 和 es6 的区别，说几个 es6 的新增方法', 1, '2023-02-09 14:31:31', 0, 'es6 熟悉吗，es5 和 es6 的区别，说几个 es6 的新增方法', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ECMAScript5，即 ES5，是 ECMAScript 的第五次修订，于 2009 年完成标准化\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ECMAScript6，即 ES6，是 ECMAScript 的第六次修订，于 2015 年完成，也称 ES2015\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 是继 ES5 之后的一次改进，相对于 ES5 更加简洁，提高了开发效率\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）新增声明命令 let 和 const\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在 es6 中通常用 let 和 const 来声明，let 表示变量、const 表示常量。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">特点：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let 和 const 都是块级作用域。以{}代码块作为作用域范围 只能在代码块里面使用。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">不存在变量提升，只能先声明再使用，否则会报错。在代码块内，在声明变量之前，该变量都\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在同一个代码块内，不允许重复声明。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">const 声明的是一个只读常量，在声明时就需要赋值。（如果 const 的是一个对象，对象所包含\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的值是可以被修改的。抽象一点儿说，就是对象所指向的地址不能改变，而变量成员是可以修\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">改的。）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）模板字符串（Template String）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">用一对反引号(`)标识，它可以当作普通字符串使用，也可以用来定义多行字符串，也可以在字\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">符串中嵌入变量，js 表达式或函数，变量、js 表达式或函数需要写在${ }中。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）函数的扩展\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">函数的默认参数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">箭头函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在 es6 中，提供了一种简洁的函数写法，我们称作“箭头函数”。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">写法：函数名=(形参)=&gt;{……} 当函数体中只有一个表达式时，{}和 return 可以省略，当函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">体中形参只有一个时，()可以省略</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">特点：箭头函数中的 this 始终指向箭头函数定义时的离 this 最近的一个函数，如果没有最近的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">函数就指向 window。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4）对象的扩展\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">属性的简写。ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">值。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var foo = \'bar\';\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var baz = {foo}; //等同于 var baz = {foo: foo};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">方法的简写。省略冒号与 function 关键字。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var o = {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> method() {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> return \"Hello!\";\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> }\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">// 等同于\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var o = {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> method: function() {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> return \"Hello!\";\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> }\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.keys()方法，获取对象的所有属性名或方法名（不包括原形的内容），返回一个数组。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var obj={name: \"john\", age: \"21\", getName: function () { alert(this.name)}};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">console.log(Object.keys(obj)); // [\"name\", \"age\", \"getName\"]\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">console.log(Object.keys(obj).length); //3\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">console.log(Object.keys([\"aa\", \"bb\", \"cc\"])); //[\"0\", \"1\", \"2\"]\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">console.log(Object.keys(\"abcdef\")); //[\"0\", \"1\", \"2\", \"3\", \"4\", \"5\"]\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.assign ()，assign 方法将多个原对象的属性和方法都合并到了目标对象上面。可以接收多\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">个参数，第一个参数是目标对象，后面的都是源对象。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var target = {}; //目标对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var source1 = {name : \'ming\', age: \'19\'}; //源对象 1\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var source2 = {sex : \'女\'}; //源对象 2\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var source3 = {sex : \'男\'}; //源对象 3，和 source2 中的对象有同名属性 sex\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.assign(target,source1,source2,source3);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">console.log(target); //{name : \'ming\', age: \'19\', sex: \'男\'}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5）for...of 循环\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var arr=[\"小林\",\"小吴\",\"小佳\"];\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">for(var v of arr){\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> console.log(v);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//小林 //小吴 //小佳\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">6）import 和 export</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 标准中，JavaScript 原生支持模块(module)了。这种将 JS 代码分割成不同功能的小块进行模\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的导入的方式可以在其他地方使用。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">export 用于对外输出本模块（一个文件可以理解为一个模块）变量的接口。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">import 用于在一个模块中加载另一个含有 export 接口的模块。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">import 和 export 命令只能在模块的顶部，不能在代码块之中。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">7）Promise 对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Promise 是异步编程的一种解决方案，将异步操作以同步操作的流程表达出来，避免了层层嵌\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">套的回调函数。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">它有三种状态，分别是 pending-进行中、resolved-已完成、rejected-已失败。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">promise 是一个异步函数，主要是为了解决异步处理回调地狱(也就是循环嵌套的问题)而产生\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的，有 3 种状态，Fulfilled 为成功的状态，Rejected 为失败的状态，Pending 既不是 Fulfilld \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">也不是 Rejected 的状态，可以理解为 Promise 对象实例创建时候的初始状态，要会写\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">promise 这个方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Promise 构造函数包含一个参数和一个带有 resolve（解析）和 reject（拒绝）两个参数的回\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">调。在回调中执行一些操作（例如异步），如果一切都正常，则调用 resolve，否则调用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">reject。对于已经实例化过的 promise 对象可以调用 promise.then() 方法，传递 resolve 和\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">reject 方法作为回调。then()方法接收两个参数：onResolve 和 onReject，分别代表当前\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">promise 对象在成功或失败时。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">8）解构赋值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（Destructuring）。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">数组的解构赋值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">数组中的值会自动被解析到对应接收该值的变量中，数组的解构赋值要一一对应 如果有对应不\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">上的就是 undefined\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">9）set 数据结构\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Set 数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">属性和方法：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">size 数据的长度\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">add() 添加某个值，返回 Set 结构本身。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">delete() 删除某个值，返回一个布尔值，表示删除是否成功。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">has() 查找某条数据，返回一个布尔值。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">clear() 清除所有成员，没有返回值。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">应用：数组去重。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（10）class \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">class 类的继承 ES6 中不再像 ES5 一样使用原型链实现继承，而是引入 Class 这个概念\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">es6 所写的类相比于 es5 的优点：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）区别于函数，更加专业化（类似于 JAVA 中的类）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">写法更加简便，更加容易实现类的继承\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（11）…\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">展开运算符可以将数组或对象里面的值展开；还可以将多个值收集为一个变量\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（12）async、await</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用 async/await, 搭配 promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">洁性和可读性 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">完成\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（13）修饰器\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">@decorator 是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（14）Symbol\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Symbol 是一种基本类型。Symbol 通过调用 symbol 函数产生，它接收一个可选的名字参数，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">该函数返回的 symbol 是唯一的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（15）Proxy\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Proxy 代理使用代理（Proxy）监听对象的操作，然后可以做一些相应事情</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (147, 'ES6 的继承和 ES5 的继承有什么区别', 1, '2023-02-09 14:31:50', 0, 'es5 的继承是通过原型或者是构造函数机制来实现，es6 用过 class 关键字定义类，里面有构造\n方法，类之间通过 extends 关键字实现，子类必须在 constructor 方法中调用 super 方法', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">es5 的继承是通过原型或者是构造函数机制来实现，es6 用过 class 关键字定义类，里面有构造\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">方法，类之间通过 extends 关键字实现，子类必须在 constructor 方法中调用 super 方法</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (148, 'var、let、const 之间的区别', 1, '2023-02-09 14:32:17', 0, 'var 声明变量可以重复声明，而 let 不可以重复声明\nvar 是不受限于块级的，而 let 是受限于块级\nvar 会与 window 相映射（会挂一个属性），而 let 不与 window 相映射\nvar 可以在声明的上面访问变量，而 let 有暂存死区，在声明的上面访问变量会报错\nconst 声明之后必须赋值，否则会报错\nconst 定义不可变的量，改变了就会报错\nconst 和 let 一样不会与 window 相映射、支持块级作用域、在声明的上面访问变量会报错', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var 声明变量可以重复声明，而 let 不可以重复声明\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var 是不受限于块级的，而 let 是受限于块级\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var 会与 window 相映射（会挂一个属性），而 let 不与 window 相映射\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var 可以在声明的上面访问变量，而 let 有暂存死区，在声明的上面访问变量会报错\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">const 声明之后必须赋值，否则会报错\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">const 定义不可变的量，改变了就会报错\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">const 和 let 一样不会与 window 相映射、支持块级作用域、在声明的上面访问变量会报错</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (149, 'Class、extends 是什么，有什么作用', 1, '2023-02-09 14:32:59', 0, 'Class、extends 是什么，有什么作用', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 的 class 可以看作只是一个 ES5 生成实例对象的构造函数的语法糖。它参考了 java 语言，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。Class\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">类可以通过 extends 实现继承。它和 ES5 构造函数的不同点：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">a. 类的内部定义的所有方法，都是不可枚举的。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">b.ES6 的 class 类必须用 new 命令操作，而 ES5 的构造函数不用 new 也可以执行。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">c.ES6 的 class 类不存在变量提升，必须先定义 class 之后才能实例化，不像 ES5 中可以将构造函\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">数写在实例化之后。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">d.ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面。ES6 \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">用 super 方法），然后再用子类的构造函数修改 this。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (150, 'module、export、import 是什么，有什么作用', 1, '2023-02-09 14:33:10', 0, 'module、export、import 是什么，有什么作用', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">module、export、import 是 ES6 用来统一前端模块化方案的设计思路和实现方案。export、\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">import 的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">代传统的 AMD/CMD、requireJS、seaJS、commondJS 等等一系列前端模块不同的实现方案，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使前端模块化更加统一规范，JS 也能更加能实现大型的应用程序开发。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">import 引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">import 引入 export 导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">值</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (151, '举例 ES6 对 String 字符串类型做的常用升级优化', 1, '2023-02-09 14:33:30', 0, '举例 ES6 对 String 字符串类型做的常用升级优化（必\n会）', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、优化部分：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 新增了字符串模板，在拼接大段字符串时，用反斜杠(`)取代以往的字符串相加的形式，能\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、升级部分:\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 在 String 原型上新增了 includes()方法，用于取代传统的只能用 indexOf 查找包含字符的方\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">法(indexOf 返回-1 表示没查到不如 includes 方法返回 false 更明确，语义更清晰), 此外还新增\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">了 startsWith(), endsWith(), padStart(),padEnd(),repeat()等方法，可方便的用于查找，补全字符\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">串</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (152, '举例 ES6 对 Array 数组类型做的常用升级优化', 1, '2023-02-09 14:33:50', 0, '举例 ES6 对 Array 数组类型做的常用升级优化', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、优化部分：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">a. 数组解构赋值。ES6 可以直接以 let [a,b,c] = [1,2,3]形式进行变量赋值，在声明较多变量时，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">不用再写很多 let(var),且映射关系清晰，且支持赋默认值。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">b. 扩展运算符。ES6 新增的扩展运算符(...)(重要),可以轻松的实现数组和松散序列的相互转化，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">可以取代 arguments 对象和 apply 方法，轻松获取未知参数个数情况下的参数集合。（尤其是\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在 ES5 中，arguments 并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（let a = [2,3,4]; let b = [...a]）。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、升级部分:\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 在 Array 原型上新增了 find()方法，用于取代传统的只能用 indexOf 查找包含数组项目的方\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">法,且修复了 indexOf 查找不到 NaN 的 bug([NaN].indexOf(NaN) === -1).此外还新增了\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">copyWithin(), includes(), fill(),flat()等方法，可方便的用于字符串的查找，补全,转换等。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (153, '举例 ES6 对 Number 数字类型做的常用升级优化', 1, '2023-02-09 14:34:04', 0, '举例 ES6 对 Number 数字类型做的常用升级优化', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、优化部分：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 在 Number 原型上新增了 isFinite(), isNaN()方法，用来取代传统的全局 isFinite(), isNaN()方\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">法检测数值是否有限、是否是 NaN。ES5 的 isFinite(), isNaN()方法都会先将非数值类型的参数转\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">化为 Number 类型再做判断，这其实是不合理的，最造成 isNaN(\'NaN\') === true 的奇怪行为--\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">\'NaN\'是一个字符串，但是 isNaN 却说这就是 NaN。而 Number.isFinite()和 Number.isNaN()则不\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">会有此类问题(Number.isNaN(\'NaN\') === false)。（isFinite()同上）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、升级部分:\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 在 Math 对象上新增了 Math.cbrt()，trunc()，hypot()等等较多的科学计数法运算方法，可以\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">更加全面的进行立方根、求和立方根等等科学计算。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (154, '举例 ES6 对 Function 函数类型做的常用升级优化', 1, '2023-02-09 14:34:16', 0, '举例 ES6 对 Function 函数类型做的常用升级优化', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、优化部分：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">a. 箭头函数(核心)。箭头函数是 ES6 核心的升级项之一，箭头函数里没有自己的 this,这改变了\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">以往 JS 函数中最让人难以理解的 this 运行机制。主要优化点:\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Ⅰ</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">. 箭头函数内的 this 指向的是函数定义时所在的对象，而不是函数执行时所在的对象。ES5\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">函数里的 this 总是指向函数执行时所在的对象，这使得在很多情况下 this 的指向变得很难理\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">解，尤其是非严格模式情况下，this 有时候会指向全局对象，这甚至也可以归结为语言层面的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">bug 之一。ES6 的箭头函数优化了这一点，它的内部没有自己的 this,这也就导致了 this 总是指\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">向上一层的 this，如果上一层还是箭头函数，则继续向上指，直到指向到有自己 this 的函数为\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">止，并作为自己的 this。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Ⅱ. 箭头函数不能用作构造函数，因为它没有自己的 this，无法实例化。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Ⅲ. 也是因为箭头函数没有自己的 this,所以箭头函数 内也不存在 arguments 对象。（可以用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">扩展运算符代替）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">b. 函数默认赋值。ES6 之前，函数的形参是无法给默认值得，只能在函数内部通过变通方法实\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">现。ES6 以更简洁更明确的方式进行函数默认赋值。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、升级部分:\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 新增了双冒号运算符，用来取代以往的 bind，call,和 apply。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">foo::bar;等同于 bar.bind(foo);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">foo::bar(...arguments)等同于 bar.apply(foo, arguments);</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (155, '举例 ES6 对 Object 类型做的常用升级优化?', 1, '2023-02-09 14:34:40', 0, '举例 ES6 对 Object 类型做的常用升级优化?', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、优化部分：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">a. 对象属性变量式声明。ES6 可以直接以变量形式声明对象属性或者方法，。比传统的键值对\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">形式声明更加简洁，更加方便，语义更加清晰。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let [apple, orange] = [\'red appe\', \'yellow orange\'];\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let myFruits = {apple, orange}; // let myFruits = {apple: \'red appe\', orange: \'yellow orange\'};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">尤其在对象解构赋值(见优化部分 b.)或者模块输出变量时，这种写法的好处体现的最为明显:\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let {keys, values, entries} = Object;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let MyOwnMethods = {keys, values, entries}; // let MyOwnMethods = {keys: keys, values: values,\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">entries: entries}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">可以看到属性变量式声明属性看起来更加简洁明了。方法也可以采用简洁写法：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let es5Fun = {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">method: function(){}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let es6Fun = {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">method(){}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">b. 对象的解构赋值。 ES6 对象也可以像数组解构赋值那样，进行变量的解构赋值：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let {apple, orange} = {apple: \'red appe\', orange: \'yellow orange\'};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">c. 对象的扩展运算符(...)。 ES6 对象的扩展运算符和数组扩展运算符用法本质上差别不大，毕竟\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">数组也就是特殊的对象。对象的扩展运算符一个最最常用也最好用的用处就在于可以轻松的取\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">出一个目标对象内部全部或者部分的可遍历属性，从而进行对象的合并和分解。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let {apple, orange, ...otherFruits} = {apple: \'red apple\', orange: \'yellow orange\', grape: \'purple \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">grape\', peach: \'sweet peach\'};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">// otherFruits {grape: \'purple grape\', peach: \'sweet peach\'}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">// 注意: 对象的扩展运算符用在解构赋值时，扩展运算符只能用在最有一个参数(otherFruits 后\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">面不能再跟其他参数)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let moreFruits = {watermelon: \'nice watermelon\'};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let allFruits = {apple, orange, ...otherFruits, ...moreFruits};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">d. super 关键字。ES6 在 Class 类里新增了类似 this 的关键字 super。同 this 总是指向当前函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">所在的对象不同，super 关键字总是指向当前函数所在对象的原型对象。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、升级部分:\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">a. ES6 在 Object 原型上新增了 is()方法，做两个目标对象的相等比较，用来完善\'===\'方法。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">\'===\'方法中 NaN === NaN //false 其实是不合理的，Object.is 修复了这个小 bug。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(Object.is(NaN, NaN) // true)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">b. ES6 在 Object 原型上新增了 assign()方法，用于对象新增属性或者多个对象合并。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">const target = { a: 1 };\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">const source1 = { b: 2 };\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">const source2 = { c: 3 };\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Object.assign(target, source1, source2);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">target // {a:1, b:2, c:3}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">注意: assign 合并的对象 target 只能合并 source1、source2 中的自身属性，并不会合并\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">source1、source2 中的继承属性，也不会合并不可枚举的属性，且无法正确复制 get 和 set 属\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">性（会直接执行 get/set 函数，取 return 的值）</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">c. ES6 在 Object 原型上新增了 getOwnPropertyDescriptors()方法，此方法增强了 ES5 中\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">getOwnPropertyDescriptor()方法，可以获取指定对象所有自身属性的描述对象。结合\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">defineProperties()方法，可以完美复制对象，包括复制 get 和 set 属性。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">d. ES6 在 Object 原型上新增了 getPrototypeOf()和 setPrototypeOf()方法，用来获取或设置当前\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">对象的 prototype 对象。这个方法存在的意义在于，ES5 中获取设置 prototype 对像是通过\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">__proto__属性来实现的，然而__proto__属性并不是 ES 规范中的明文规定的属性，只是浏览器\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">各大产商“私自”加上去的属性，只不过因为适用范围广而被默认使用了，再非浏览器环境中\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">并不一定就可以使用，所以为了稳妥起见，获取或设置当前对象的 prototype 对象时，都应该\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">采用 ES6 新增的标准用法。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">e. ES6 在 Object 原型上还新增了 Object.keys()，Object.values()，Object.entries()方法，用来获\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">取对象的所有键、所有值和所有键值对数组。&nbsp;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (156, '使用箭头函数应注意什么/箭头函数和普通函数的区别', 1, '2023-02-09 14:34:55', 0, '使用箭头函数应注意什么/箭头函数和普通函数的区别', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">用了箭头函数，this 就不是指向 window，而是父级（指向是可变的）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">不能够使用 arguments 对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">不能用作构造函数，这就是说不能够使用 new 命令，否则会抛出一个错误\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (157, 'ES6 的模板字符串有哪些新特性？并实现一个类模板字 符串的功能', 1, '2023-02-09 14:35:19', 0, 'ES6 的模板字符串有哪些新特性？并实现一个类模板字 符串的功能', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在 ES5 时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6 反引号(``)就能解决\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">类模板字符串的功能\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let name = \'sunny\';\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let age = 21;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let str = \'你好，${name} 已经 ${age}岁了\'\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">str = str.replace(/\\$\\{([^}]*)\\}/g,function(){\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> return eval(arguments[1]);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> })\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">console.log(str);//你好，sunny 已经 21 岁了</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (158, '介绍下 Set、Map 的区别', 1, '2023-02-09 14:35:41', 0, '介绍下 Set、Map 的区别', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">应用场景 Set 用于数据重组，Map 用于数据储存\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Set：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">成员不能重复\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">只有键值没有键名，类似数组\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">可以遍历，方法有 add, delete,has\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Map:\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">本质上是健值对的集合，类似集合\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">可以遍历，可以跟各种数据格式转换</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (159, 'setTimeout、Promise、Async/Await 的区别', 1, '2023-02-09 14:35:56', 0, '事件循环中分为宏任务队列和微任务队列\n其中 setTimeout 的回调函数放到宏任务队列里，等到执行栈清空以后执行\npromise.then 里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行\n完再执行\nasync 函数表示函数里面可能会有异步方法，await 后面跟一个表达式\nasync 方法执行时，遇到 await 会立即执行表达式，然后把表达式后面的代码放到微任务队列\n里，让出执行栈让同步代码先执行', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">事件循环中分为宏任务队列和微任务队列\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">其中 setTimeout 的回调函数放到宏任务队列里，等到执行栈清空以后执行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">promise.then 里的回调函数会放到相应宏任务的微任务队列里，等宏任务里面的同步代码执行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">完再执行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">async 函数表示函数里面可能会有异步方法，await 后面跟一个表达式\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">async 方法执行时，遇到 await 会立即执行表达式，然后把表达式后面的代码放到微任务队列\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">里，让出执行栈让同步代码先执行</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (160, 'promise 有几种状态，什么时候会进入 catch？', 1, '2023-02-09 14:36:17', 0, '三个状态：pending、fulfilled、reject\n两个过程：padding -> fulfilled、padding -> rejected\n当 pending 为 rejectd 时，会进入 catch', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">三个状态：pending、fulfilled、reject\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">两个过程：padding -&gt; fulfilled、padding -&gt; rejected\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当 pending 为 rejectd 时，会进入 catch</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (161, 'ECMAScript 6 怎么写 class ，为何会出现 class', 1, '2023-02-09 14:37:02', 0, 'ECMAScript 6 怎么写 class ，为何会出现 class', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 的 class 可以看作是一个语法糖，它的绝大部分功能 ES5 都可以做到，新的 class 写法只是\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">让对象原型的写法更加清晰、更像面向对象编程的语法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//定义类\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">class Point {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> constructor(x,y) {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> //构造方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> this.x = x; //this 关键字代表实例对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> this.y = y;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> } toString() {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">}</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> return \'(\' + this.x + \',\' + this.y + \')\';\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> }</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (162, 'Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？', 1, '2023-02-09 14:37:16', 0, 'Promise 构造函数是同步执行还是异步执行，那么\nthen 方法呢？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">promise 构造函数是同步执行的，then 方法是异步执行的</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (163, 'promise 只有成功和失败 2 个状态，怎么让一个函数无论 成功还是失败都能被调用？', 1, '2023-02-09 14:37:32', 0, 'promise 只有成功和失败 2 个状态，怎么让一个函数无论\n成功还是失败都能被调用？', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用 promise.all()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Promise.all 方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Promise.all 方法接受一个数组作为参数，数组里的元素都是 Promise 对象的实例，如果不是，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">就会先调用下面讲到的 Promise.resolve 方法，将参数转为 Promise 实例，再进一步处理。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（Promise.all 方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Promise 实例。）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">示例：var p =Promise.all([p1,p2,p3]);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">p 的状态由 p1、p2、p3 决定，分为两种情况。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当该数组里的所有 Promise 实例都进入 Fulfilled 状态：Promise.all**返回的实例才会变成\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Fulfilled 状态。并将 Promise 实例数组的所有返回值组成一个数组，传递给 Promise.all 返回实\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">例的回调函数**。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当该数组里的某个 Promise 实例都进入 Rejected 状态：Promise.all 返回的实例会立即变成\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Rejected 状态。并将第一个 rejected 的实例返回值传递给 Promise.all 返回实例的回调函数</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (164, 'es6 如何转化为 es5，为什么要转化', 1, '2023-02-09 14:38:00', 0, 'es6 如何转化为 es5，为什么要转化', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ECMAScript2015，更新语法、规则、功能，浏览器对 ES6 的支持程度并不是很好，如果写了\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 的代码，需要运行在浏览器上的时候，需要将 ES6 的代码转成 ES5 的代码去浏览器上运\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">行。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Babel 是什么?</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">babel 是一个 ES6 转码器，可以将 ES6 代码转为 ES5 代码，以便兼容那些还没支持 ES6 的平\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">台。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (165, '日常前端代码开发中，有哪些值得用 ES6 去改进的编 程优化或者规范', 1, '2023-02-09 14:38:18', 0, '日常前端代码开发中，有哪些值得用 ES6 去改进的编程优化或者规范', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、常用箭头函数来取代 var self = this;的做法。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、常用 let 取代 var 命令。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、常用数组/对象的结构赋值来命名变量，结构更清晰，语义更明确，可读性更好。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4、在长字符串多变量组合场合，用模板字符串来取代字符串累加，能取得更好地效果和阅读体\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">验。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5、用 Class 类取代传统的构造函数，来生成实例化对象。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">6、在大型应用开发中，要保持 module 模块化开发思维，分清模块之间的关系，常用 import、\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">export 方法。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (166, 'ES6 和 node 的 commonjs 模块化规范的区别', 1, '2023-02-09 14:38:37', 0, 'es6 是 js 的增强版，是 js 的语法规范，commonjs 都只是为了解决 js 文件之间的依赖和引用问\n题，所以是一种 js 的包管理规范，其中的代表是 Node 遵循 commonjs 规范', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">es6 是 js 的增强版，是 js 的语法规范，commonjs 都只是为了解决 js 文件之间的依赖和引用问\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">题，所以是一种 js 的包管理规范，其中的代表是 Node 遵循 commonjs 规范</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (167, 'Promise 中 reject 和 catch 处理上有什么区别', 1, '2023-02-09 14:38:52', 0, 'reject 是用来抛出异常，catch 是用来处理异常\nreject 是 Promise 的方法，而 catch 是 Promise 实例的方法\nreject 后的东西，一定会进入 then 中的第二个回调，如果 then 中没有写第二个回调，则进入\ncatch\n网络异常（比如断网），会直接进入 catch 而不会进入 then 的第二个回调', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">reject 是用来抛出异常，catch 是用来处理异常\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">reject 是 Promise 的方法，而 catch 是 Promise 实例的方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">reject 后的东西，一定会进入 then 中的第二个回调，如果 then 中没有写第二个回调，则进入\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">catch\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">网络异常（比如断网），会直接进入 catch 而不会进入 then 的第二个回调</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (168, '理解 async/await 以及对 Generator 的优势', 1, '2023-02-09 14:39:05', 0, '理解 async/await 以及对 Generator 的优势', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">async await 是用来解决异步的，async 函数是 Generator 函数的语法糖\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用关键字 async 来表示，在函数内部使用 await 来表示异步\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">面的语句\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">async 较 Generator 的优势：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">内置执行器。Generator 函数的执行必须依靠执行器，而 Aysnc 函数自带执行器，调用方式跟\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">普通函数的调用一样\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">更好的语义。async 和 await 相较于 * 和 yield 更加语义化\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">更广的适用性。yield 命令后面只能是 Thunk 函数或 Promise 对象，async 函数的 await 后面可\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">以是 Promise 也可以是原始类型的值\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">返回值是 Promise。async 函数返回的是 Promise 对象，比 Generator 函数返回的 Iterator 对\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">象方便，可以直接使用 then() 方法进行调用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">generator 函数就是一个封装的异步任务，也就是异步任务的容器，执行 Generator 函数会返\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">回一个遍历器对象,async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">里</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (169, '手写一个 promise', 1, '2023-02-09 14:39:32', 0, '手写一个 promise', 21, '<pre><code>var promise = new Promise((resolve, reject) =&gt; {\n if (操作成功) {\n resolve(value)\n } else {\n reject(error)\n }\n})\npromise.then(function (value) {\n // success\n}, function (value) {\n // failure\n})</code></pre><p><br></p>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (170, '使用结构赋值，实现两个变量的值的交换', 1, '2023-02-09 14:42:03', 0, '使用结构赋值，实现两个变量的值的交换', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let a = 1;let b = 2;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">[a,b] = [b,a];</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (171, '设计一个对象，键名的类型至少包含一个 symbol 类 型，并且实现遍历所有 key', 1, '2023-02-09 14:42:22', 0, '设计一个对象，键名的类型至少包含一个 symbol 类 型，并且实现遍历所有 key', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let name = Symbol(\'name\');\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let product = {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> [name] : \"平衡车\", \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> \"price\" : 1999\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Reflect.ownKeys(product);</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (172, '说一下 es6 的导入导出模块', 1, '2023-02-09 14:42:37', 0, '说一下 es6 的导入导出模块', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">导入通过 import 关键字\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">// 只导入一个\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">import {sum} from \"./example.js\"\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">// 导入多个\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">import {sum,multiply,time} from \"./exportExample.js\"\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">// 导入一整个模块\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">import * as example from \"./exportExample.js\"\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">导出通过 export 关键字</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//可以将 export 放在任何变量,函数或类声明的前面\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">export var firstName = \'Chen\';\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">export var lastName = \'Sunny\';\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">export var year = 1998;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//也可以使用大括号指定所要输出的一组变量\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var firstName = \'Chen\';\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var lastName = \'Sunny\';\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var year = 1998;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">export {firstName, lastName, year};\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//使用 export default 时，对应的 import 语句不需要使用大括号\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let bosh = function crs(){}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">export default bosh;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">import crc from \'crc\';\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//不使用 export default 时，对应的 import 语句需要使用大括号\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">let bosh = function crs(){}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">export bosh;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">import {crc} from \'crc\';</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (173, 'ajax 应用和传统 web 应用有什么不同', 1, '2023-02-09 14:52:42', 0, '1.在传统的 JavaScript 编程中，用户需要点击“submit”按钮来发送或者接收数据信息，然后等\n待服务器响应请求，需要重新加载整个页面。\n2.使用 ajax 技术，就可以使 javascript 通过 XMLHTTPRequest 对象直接与服务器进行交互。\n3.通过 HTTP Request，一个 web 页面可以发送一个请求到 web 服务器并且接收 web 服务器返\n回的信息（不用重新加载页面），展示给用户的还是同一个页面，用户感觉页面刷新，也看不\n到 JavaScript 后台进行的发送请求和接收响应。', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1.在传统的 JavaScript 编程中，用户需要点击“submit”按钮来发送或者接收数据信息，然后等\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">待服务器响应请求，需要重新加载整个页面。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2.使用 ajax 技术，就可以使 javascript 通过 XMLHTTPRequest 对象直接与服务器进行交互。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3.通过 HTTP Request，一个 web 页面可以发送一个请求到 web 服务器并且接收 web 服务器返\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">回的信息（不用重新加载页面），展示给用户的还是同一个页面，用户感觉页面刷新，也看不\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">到 JavaScript 后台进行的发送请求和接收响应。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 28, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (174, 'AJAX 请求总共有多少种 CALLBACK', 1, '2023-02-09 14:53:46', 0, 'Ajax 请求总共有八种 Callback\n1）onSuccess 2）onFailure 3）onUninitialized 4）onLoading 5）onLoaded 6）\nonInteractive 7）onComplete\n8）onException', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Ajax 请求总共有八种 Callback\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）onSuccess 2）onFailure 3）onUninitialized 4）onLoading 5）onLoaded 6）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onInteractive 7）onComplete\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">8）onException</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 28, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (175, '什么是 AJAX，AJAX 都有哪些优点和缺点？', 1, '2023-02-09 14:54:20', 0, 'AJAX 是“Asynchronous JavaScript and XML”的缩写。他是指一种创建交互式网页应用的网页\n开发技术。\n客户端与服务器，可以在【不必刷新整个浏览器】的情况下，与服务器进行异步通讯的技术\nAjax 的原理', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">AJAX 是“Asynchronous JavaScript and XML”的缩写。他是指一种创建交互式网页应用的网页\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">开发技术。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">客户端与服务器，可以在【不必刷新整个浏览器】的情况下，与服务器进行异步通讯的技术\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Ajax 的原理</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">通过 XmlHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后用 javascript 来操\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">作 DOM 而更新页面。这其中最关键的一步就是从服务器获得请求数据。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">XMLHttpRequest 是 ajax 的核心机制，它是在 IE5 中首先引入的，是一种支持异步请求的技术。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">简单的说，也就是 javascript 可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">新的效果。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ajax 的优点\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> 1、最大的一点是页面无刷新，用户的体验非常好。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> 2、使用异步方式与服务器通信，具有更加迅速的响应能力。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> 3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax 的原则是“按\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> 4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ajax 的缺点\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> 1、ajax 不支持浏览器 back 按钮。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> 2、安全问题 AJAX 暴露了与服务器交互的细节</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、对搜索引擎的支持比较弱。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> 4、破坏了程序的异常机制。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> 5、不容易调试。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 28, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (176, '常见的 http 状态码以及代表的意义', 1, '2023-02-09 14:54:35', 0, '常见的 http 状态码以及代表的意义', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5 种常见的 http 状态码以及代表的意义如下：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">200（ </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">OK）：请求已成功，请求所希望的响应头或数据体将随此响应返回。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">303（ </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">See Other）：告知客户端使用另一个 URL 来获取资源。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">400（ </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Bad Request）：请求格式错误。1)语义有误，当前请求无法被服务器理解。除非进行修\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">改，否则客户端不应该重复提交这个请求；2)请求参数有误。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">404（ </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Not Found）：请求失败，请求所希望得到的资源未被在服务器上发现。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">500（ </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Internal Server Error）：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的处理。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">100 =&gt; 正在初始化（一般是看不到的）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">101 =&gt; 正在切换协议（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">websocket 浏览器提供的）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">202 =&gt; 表示接受\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">301 =&gt; 永久重定向/永久转移\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">302 =&gt; 临时重定向/临时转移（一般用来做服务器负载均衡）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">304 =&gt; 本次获取的内容是读取缓存中的数据，会每次去服务器校验\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">401 =&gt; 未认证，没有登录网站\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">403 =&gt; 禁止访问，没有权限\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">503 =&gt; 服务器超负荷（假设一台服务器只能承受 10000 人，当第 10001 人访问的时候，如果\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">服务器没有做负载均衡，那么这个人的网络状态码就是 503）</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 28, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (177, '请介绍一下 XMLhttprequest 对象及常用方法和属性（必 会）', 1, '2023-02-09 14:55:07', 0, '请介绍一下 XMLhttprequest 对象及常用方法和属性', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Ajax 的核心是 JavaScript 对象 XmlHttpRequest。该对象在 Internet Explorer 5 中首次引入，它是\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">一种支持异步请求的技术。简而言之，XmlHttpRequest 使您可以使用 JavaScript 向服务器提出\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">请求并处理响应，而不阻塞用户。通过 XMLHttpRequest 对象，Web 开发人员可以在页面加载\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">以后进行页面的局部更新\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">open()(String method,String url,boolean asynch,String username,String password)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">send(content)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">setRequestHeader(String header,String value)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">getAllResponseHeaders()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">getResponseHeader(String header)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">abort()</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">常用的方法就是黑色粗体的前三个\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">open()：该方法创建 http 请求\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">第一个参数是指定提交方式(post、get)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">第二个参数是指定要提交的地址是哪\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">第三个参数是指定是异步还是同步(true 表示异步，false 表示同步)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">第四和第五参数在 http 认证的时候会用到。是可选的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">setRequestHeader(String header,String value)：设置消息头（使用 post 方式才会使用到，get 方\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">法并不需要调用该方法）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">xmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">send(content)：发送请求给服务器\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">如果是 get 方式，并不需要填写参数，或填写 null\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">如果是 post 方式，把要提交的参数写上去\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">属性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">onreadystatechange：请求状态改变的事件触发器（readyState 变化时会调用此方法），一般用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">于指定回调函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">readyState：请求状态 readyState 一改变，回调函数被调用，它有 5 个状态\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">0：未初始化\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1：open 方法成功调用以后\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2：服务器已经应答客户端的请求\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3：交互中。Http 头信息已经接收，响应数据尚未接收。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4：完成。数据接收完成\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">responseText：服务器返回的文本内容\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">responseXML：服务器返回的兼容 DOM 的 XML 内容\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">status：服务器返回的状态码\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">statusText：服务器返回状态码的文本信息\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">上面有两个地方都提及了回调函数，回调函数是什么？？\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">回调函数就是接收服务器返回的内容！</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 28, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (178, 'Ajax 的实现流程是怎样的？', 1, '2023-02-09 14:55:34', 0, 'Ajax 的实现流程是怎样的？', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(1)创建 XMLHttpRequest 对象,也就是创建一个异步调用对象.\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(2)创建一个新的 HTTP 请求,并指定该 HTTP 请求的方法、URL 及验证信息.\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(3)设置响应 HTTP 请求状态变化的函数.\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(4)发送 HTTP 请求.\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(5)获取异步调用返回的数据.\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(6)使用 JavaScript 和 DOM 实现局部刷新.\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> &lt;script type=\"text/javascript\"&gt;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> var httpRequest;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> function checkUsername() {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//创建 XMLHttpRequest 对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> if(window.XMLHttpRequest) {</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//在 IE6 以上的版本以及其他内核的浏览器(Mozilla)等\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> httpRequest = new XMLHttpRequest();\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> }else if(window.ActiveXObject) {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> //在 IE6 以下的版本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> httpRequest = new ActiveXObject();\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> }\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> //创建 http 请求\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> httpRequest.open(\"POST\", \"Servlet1\", true);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> //因为我使用的是 post 方式，所以需要设置消息头\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> httpRequest.setRequestHeader(\"Content-type\", \"application/x-www-form</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">urlencoded\");\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> //指定回调函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> httpRequest.onreadystatechange = response22;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> //得到文本框的数据\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> var name = document.getElementById(\"username\").value;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> //发送 http 请求，把要检测的用户名传递进去\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> httpRequest.send(\"username=\" + name);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> }\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//接收服务器响应数据\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> function response22() {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> //判断请求状态码是否是 4【数据接收完成】\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> if(httpRequest.readyState==4) {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> //再判断状态码是否为 200【200 是成功的】\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> if(httpRequest.status==200) {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> //得到服务端返回的文本数据\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> var text = httpRequest.responseText;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> //把服务端返回的数据写在 div 上\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> var div = document.getElementById(\"result\");\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> div.innerText = text;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> }}}&lt;/script&gt;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 28, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (179, 'ajax 接收到的数据类型有哪些，数据如何处理？', 1, '2023-02-09 14:55:53', 0, 'ajax 接收到的数据类型有哪些，数据如何处理？', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">接收到的数据类型：String /JSON 字符串/JSON 对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JSON 对象直接循环使用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JSON 字符串转 JSON 使用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">String 直接使用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//字符串转对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">第一种方式：eval（）；</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var data=\'{\"student\"：[{\"name\":\"张三\",\"age\":\"11\"}，{\"name\":\"李四\",\"age\":\"11\"},{\"name\":\"王五\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">\",\"age\":\"11\"}]}’；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">eval（’（“</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">+data+”）’）;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">第二种方式：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JSON.parse（）；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var data=\'{\"student\"：[{\"name\":\"张三\",\"age\":\"11\"}，{\"name\":\"李四\",\"age\":\"11\"},{\"name\":\"王五\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">\",\"age\":\"11\"}]}’；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JSON.parse（data）；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">区别：eval 方法不会去检查给的字符串时候符合 json 的格式~同时如果给的字符串中存在 js 代\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">码 eval 也会一并执行~比如:\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var data=\'{\"student\"：[{\"name\":\"张三\",\"age\":\"11\"}，{\"name\":\"李四\",\"age\":\"alert(11)\"},{\"name\":\"王\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">五\",\"age\":\"11\"}]}’；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">此时执行 eval 方法后会先弹出一个提示框输出 11 的字符串;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">这时候使用 JSON.parse()就会报错,显示错误信息为当前字符串不符合 json 格式;即 JSON.parse()\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">方法会检查需要转换的字符串是否符合 json 格式.\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">相比而言 eval 方法是很不安全，特别是当涉及到第三方时我们需要确保传给 eval 的参数是我们\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">可以控制的，不然里面插入比如 window.location~指向一个恶意的连接总的来说，还是推荐使\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">用 JSON.parse 来实现 json 格式字符串的解析\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">// 对象转字符串\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JSON.stringify(json)</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 28, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (180, '请解释一下 JavaScript 的同源策略', 1, '2023-02-09 14:56:17', 0, '请解释一下 JavaScript 的同源策略', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">同源策略是客户端脚本（尤其是 Javascript）的重要的安全度量标准。它最早出自 Netscape \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是：协议，域\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">属性</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 29, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (181, '阐述一下异步加载 JS', 1, '2023-02-09 14:56:34', 0, '阐述一下异步加载 JS', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">异步加载的方案： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">动态插入 script 标签\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">通过 ajax 去获取 js 代码，然后通过 eval 执行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">script 标签上添加 defer 或者 async 属性\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">创建并插入 iframe，让它异步执行 js\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">参考资料：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">https://www.cnblogs.com/zichi/p/4597766.html\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">https://www.cnblogs.com/xkloveme/articles/7569426.html</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (182, '为什么会有跨域的问题出现，如何解决跨域问题（必 会）', 1, '2023-02-09 14:56:54', 0, '跨域,指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的,是浏览器对\njavascript 施加的安全限制，防止他人恶意攻击网站', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">跨域,指的是浏览器不能执行其他网站的脚本，它是由浏览器的同源策略造成的,是浏览器对\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">javascript 施加的安全限制，防止他人恶意攻击网站</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">比如一个黑客,他利用 iframe 把真正的银行登录页面嵌到他的页面上,当你使用真实的用户名和\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">密码登录时,如果没有同源限制,他的页面就可以通过 JavaScript 读取到你的表单中输入的内容,\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">这样用户名和密码就轻松到手了。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">解决方式：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1.jsonp\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">原理：动态创建一个 script 标签。利用 script 标签的 src 属性不受同源策略限制。因为所有的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">src 属性和 href 属性都不受同源策略限制。可以请求第三方服务器数据内容。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">步骤：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1. 去创建一个 script 标签\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2. script 的 src 属性设置接口地址\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3. 接口参数,必须要带一个自定义函数名 要不然后台无法返回数据。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4. 通过定义函数名去接收后台返回数据\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//去创建一个 script 标签\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">var script = document.createElement(\"script\");\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//script 的 src 属性设置接口地址 并带一个 callback 回调函数名称\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">script.src = \"http://127.0.0.1:8888/index.php?callback=jsonpCallback\";\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//插入到页面\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">document.head.appendChild(script);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//通过定义函数名去接收后台返回数据 function jsonpCallback(data){\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> //注意 jsonp 返回的数据是 json 对象可以直接使用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> //ajax 取得数据是 json 字符串需要转换成 json 对象才可以使用。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2. CORS：跨域资源共享\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">原理：服务器设置 Access-Control-Allow-OriginHTTP 响应头之后，浏览器将会允许跨域请求\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">限制：浏览器需要支持 HTML5，可以支持 POST，PUT 等方法兼容 ie9 以上\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">需要后台设置\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Access-Control-Allow-Origin: * //允许所有域名访问，或者\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Access-Control-Allow-Origin: http://a.com //只允许所有域名访问\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3.反向代理\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4.window+iframe&nbsp;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (183, 'Get 和 Post 的区别？什么情况下用到', 1, '2023-02-09 14:57:31', 0, 'Get 和 Post 的区别？什么情况下用到', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）GET 使用 URL 或 Cookie 传参。而 POST 将数据放在 BODY 中</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）GET 的 URL 会有长度上的限制，则 POST 的数据则可以非常大\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）POST 比 GET 安全，因为数据在地址栏上不可见\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">最本质的区别\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Get 是用来从服务器上获得数据，而 post 是用来向服务器上传递数据\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">若符合下列任一情况，则用 post 方法：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">A）请求的结果有持续性的作用，例如：数据库内添加新的数据行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">B）若使用 get 方法，则表单上收集的数据可能让 URL 过长\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">C）要传送的数据不是采用 ASCII 编码\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">若符合下列任一情况，则用 get 方法：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">A）请求是为了查找资源，html 表单数据仅用来搜索\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">B）请求结果无持续性的副作用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">C）收集的数据及 html 表单内的输入字段名称的总长不超过 1024 个字符</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 28, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (184, '解释 jsonp 的原理', 1, '2023-02-09 14:57:56', 0, 'Jsonp 并不是一种数据格式，而 json 是一种数据格式，jsonp 是用来解决跨域获取数据的一种解\n决方案，具体是通过动态创建 script 标签，然后通过标签的 src 属性获取 js 文件中的 js 脚本，\n该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要\n事先在页面定义好回调函数，本质上使用的并不是 ajax 技术，\najax 请求受同源策略的影响，不允许进行跨域请求，而 script 标签的 src 属性中的链接却可以访\n问跨域的 js 脚本，利用这个特性，服务端不在返回 json 格式的数据，而是返回调用某个函数的\njs 代码，在 src 中进行了调用，这样就实现了跨域，其原理就是动态创建 script 标签，通过\nscript 标签的 src 属性进行调用', 21, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Jsonp 并不是一种数据格式，而 json 是一种数据格式，jsonp 是用来解决跨域获取数据的一种解\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">决方案，具体是通过动态创建 script 标签，然后通过标签的 src 属性获取 js 文件中的 js 脚本，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">事先在页面定义好回调函数，本质上使用的并不是 ajax 技术，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ajax 请求受同源策略的影响，不允许进行跨域请求，而 script 标签的 src 属性中的链接却可以访\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">问跨域的 js 脚本，利用这个特性，服务端不在返回 json 格式的数据，而是返回调用某个函数的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">js 代码，在 src 中进行了调用，这样就实现了跨域，其原理就是动态创建 script 标签，通过\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">script 标签的 src 属性进行调用</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 23, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (185, '工作当中封装好的 ajax 里的几个参数', 1, '2023-02-09 14:58:16', 0, 'url: 发送请求的地址。\ntype: 请求方式（post 或 get）默认为 get。\nasync: 同步异步请求，默认 true 所有请求均为异步请求。\ntimeout : 超时时间设置，单位毫秒\ndata：要求为 Object 或 String 类型的参数，发送到服务器的数据\ncache：默认为 true（当 dataType 为 script 时，默认为 false）, 设置为 false 将不会从浏览器缓\n存中加载请求信息。\ndataType: 预期服务器返回的数据类型。\n可用的类型如下：\nxml：返回 XML 文档，可用 JQuery 处理。\nhtml：返回纯文本 HTML 信息；包含的 script 标签会在插入 DOM 时执行。\nscript：返回纯文本 JavaScript 代码。不会自动缓存结果。\njson：返回 JSON 数据。', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">url: 发送请求的地址。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">type: 请求方式（post 或 get）默认为 get。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">async: 同步异步请求，默认 true 所有请求均为异步请求。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">timeout : 超时时间设置，单位毫秒\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">data：要求为 Object 或 String 类型的参数，发送到服务器的数据\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">cache：默认为 true（当 dataType 为 script 时，默认为 false）, 设置为 false 将不会从浏览器缓\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">存中加载请求信息。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">dataType: 预期服务器返回的数据类型。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">可用的类型如下：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">xml：返回 XML 文档，可用 JQuery 处理。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">html：返回纯文本 HTML 信息；包含的 script 标签会在插入 DOM 时执行。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">script：返回纯文本 JavaScript 代码。不会自动缓存结果。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">json：返回 JSON 数据。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">jsonp：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">JSONP 格式。使用 JSONP 形式调用函数时，例如 myurl?callback=?，JQuery 将自动替\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">换后一个“</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">?”为正确的函数名，以执行回调函数。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">text：返回纯文本字符串。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">success：请求成功后调用的回调函数，有两个参数。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(1) 由服务器返回，并根据 dataType 参数进行处理后的数据。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(2) 描述状态的字符串。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">error：要求为 Function 类型的参数，请求失败时被调用的函数。该函数有 3 个参数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(1) XMLHttpRequest 对象\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(2) 错误信息\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">(3) 捕获的错误对象(可选)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">complete :function(XMLHttpRequest,status){ //请求完成后最终执行参数}</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 28, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (186, 'jQuery 中 ajax 、fetch、 axios 有什么异同，适用场景 有哪些？', 1, '2023-02-09 14:59:06', 0, 'jQuery 中 ajax 、fetch、 axios 有什么异同，适用场景 有哪些？', 23, '<div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">. jQuery ajax \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">$.ajax({ \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">type: \'POST\', \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">url: url, \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">data: data, \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">dataType: dataType,\n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">success: function () {}, \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">error: function (){} \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\">}); \n</spanyes\';font-size:9.12pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">优缺点： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">本身是针对 MVC 的编程,不符合现在前端 MVVM 的浪潮\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">JQuery 整个项目太大，单纯使用 ajax 却要引入整个 JQuery 非常的不合理（采取个性化打\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">包的方案又不能享受 CDN 服务）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2.axios axios({\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">method: \'post\',\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">url: \'/user/12345\',\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">data: {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"> firstName: \'Fred\',\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"> lastName: \'Flintstone\'\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">} }) .then(function (response) {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">console.log(response);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">})\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">客户端支持防止 CSRF/XSRF 自动转换 JSON 数据 取消请求 转换请求和响应数据 拦截请求和\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">响应 支持 Promise API 从 node.js 发出 http 请求 从浏览器中创建</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">XMLHttpRequest axios 是一个基于 Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">有以下特征：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">为什么要用 axios? \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">1）fetch 没有办法原生监测请求的进度，而 XHR 可以\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">2）fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">并不能阻止请求过程继续在后台运行，造成了量的浪费\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3）fetch 默认不会带 cookie，需要添加配置项 1）fetchtch 只对网络请求报错，对 400，500 都\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">当做成功的请求，需要封装去处理\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">脱离了 XHR，是 ES 规范里新的实现方式 更加底层，提供的 API 丰富（request, response） 更\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">好更方便的写法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里 优缺点： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">}\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">let data =response.json();\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">let response = await fetch(url);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">try {\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">catch(e) { console.log(data);\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">console.log(\"Oops,error\", e); }\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">3.fetch 提供了一些并发请求的接口（重要，方便了很多的操作） 客户端支持防止 CSRF 支持\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">Promise API 从 node.js 创建 http 请求 优缺点： </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">});\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\">console.log(error); .catch(function (error) { })</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(51,51,51);\"></div>', 28, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (187, 'AJAX 注意事项及适用和不适用场景', 1, '2023-02-09 14:59:32', 0, 'AJAX 注意事项及适用和不适用场景', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Ajax 开发时，网络延迟——即用户发出请求到服务器发出响应之间的间隔——需要慎重考虑。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">不给予用户明确的回应，没有恰当的预读数据，或者对 XMLHttpRequest 的不恰当处理，都会\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用户感到延迟，这是用户不希望看到的，也是他们无法理解的。通常的解决方案是，使用一\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">个可视化的组件来告诉用户系统正在进行后台操作并且正在读取数据和内容。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Ajax 适用场景\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;1&gt;.表单驱动的交互\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;2&gt;.深层次的树的导航\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;3&gt;.快速的用户与用户间的交流响应\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;4&gt;.类似投票、yes/no 等无关痛痒的场景\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;5&gt;.对数据进行过滤和操纵相关数据的场景\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;6&gt;.普通的文本输入提示和自动完成的场景\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Ajax 不适用场景\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;1&gt;.部分简单的表单\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;2&gt;.搜索\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;3&gt;.基本的导航\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;4&gt;.替换大量的文本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;5&gt;.对呈现的操纵</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 28, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (188, 'HTTP 与 HTTPS 的区别', 1, '2023-02-09 14:59:57', 0, 'HTTP 与 HTTPS 的区别', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、HTTPS 协议需要到 CA （Certificate Authority，证书颁发机构）申请证书，一般免费证书\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">较少，因而需要一定费用。(以前网易官网是 http，而网易邮箱是 https 。)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">议。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">443。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4、HTTP 的连接很简单，是无状态的。HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">输、身份认证的网络协议，比 HTTP 协议安全。(无状态的意思是其数据包的发送、传输和接\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">收都是相互独立的。无连接的意思是指通信双方都不长久的维持对方的任何信息。)</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 29, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (189, '简述 web 前端 cookie 机制，并结合该机制说明会话保 持原理？', 1, '2023-02-09 15:00:19', 0, '简述 web 前端 cookie 机制，并结合该机制说明会话保\n持原理？', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Cookie 是进行网站用户身份，实现服务端 Session 会话持久化的一种非常好方式。Cookie 最早\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">由 Netscape 公司开发，现在由 IETF 的 RFC 6265 标准备对其规范，已被所有主流浏览器所支\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">持。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1. 为什么需要 Cookie？\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">HTTP 是一种无状态的协议，客户端与服务器建立连接并传输数据，数据传输完成后，连接就\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">会关闭。再次交互数据需要建立新的连接，因此，服务器无法从连接上跟踪会话，也无法知道\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">用户上一次做了什么。这严重阻碍了基于 Web 应用程序的交互，也影响用户的交互体验。如：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在网络有时候需要用户登录才进一步操作，用户输入用户名密码登录后，浏览了几个页面，由\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">于 HTTP 的无状态性，服务器并不知道用户有没有登录。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Cookie 是解决 HTTP 无状态性的有效手段，服务器可以设置或读取 Cookie 中所包含的信\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">息。当用户登录后，服务器会发送包含登录凭据的 Cookie 到用户浏览器客户端，而浏览器对该\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Cookie 进行某种形式的存储（内存或硬盘）。用户再次访问该网站时，浏览器会发送该 Cookie\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（Cookie 未到期时）到服务器，服务器对该凭据进行验证，合法时使用户不必输入用户名和密\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">码就可以直接登录。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">本质上讲，Cookie 是一段文本信息。客户端请求服务器时，如果服务器需要记录用户状态，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">就在响应用户请求时发送一段 Cookie 信息。客户端浏览器保存该 Cookie 信息，当用户再次访\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">问该网站时，浏览器会把 Cookie 做为请求信息的一部分提交给服务器。服务器检查 Cookie 内\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">容，以此来判断用户状态，服务器还会对 Cookie 信息进行维护，必要时会对 Cookie 内容进行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">修改。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2. Cookie 的类型\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Cookie 总时由用户客户端进行保存的（一般是浏览器），按其存储位置可分为：内存式\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Cookie 和硬盘式 Cookie。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">内存式 Cookie 存储在内存中，浏览器关闭后就会消失，由于其存储时间较短，因此也被称\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">为非持久 Cookie 或会话 Cookie。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">硬盘式 Cookie 保存在硬盘中，其不会随浏览器的关闭而消失，除非用户手工清理或到了过\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">期时间。由于硬盘式 Cookie 存储时间是长期的，因此也被称为持久 Cookie。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3. Cookie 的实现原理\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Cookie 定义了一些 HTTP 请求头和 HTTP 响应头，通过这些 HTTP 头信息使服务器可以与客\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">户进行状态交互。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">客户端请求服务器后，如果服务器需要记录用户状态，服务器会在响应信息中包含一个 Set</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Cookie 的响应头，客户端会根据这个响应头存储 Cookie 信息。再次请求服务器时，客户端会\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在请求信息中包含一个 Cookie 请求头，而服务器会根据这个请求头进行用户身份、状态等较\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">验。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">下面是一个实现 Cookie 机制的，简单的 HTTP 请求过程：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1. 客户端请求服务器\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">客户端请求 IT 笔录网站首页，请求头如下：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">GET / HTTP/1.0\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">HOST: itbilu.com\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2. 服务器响应请求\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Cookie 是一种 key=value 形式的字符串，服务器需要记录这个客户端请求的状态，因此在响\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">应头中包一个 Set-Cookie 字段。响应头如下：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">HTTP/1.0 200 OK\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Content-type: text/html\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">……\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3. 再次请求时，客户端请求中会包含一个 Cookie 请求头\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">客户端会对服务器响应的 Set-Cookie 头信息进行存储。再次请求时，将会在请求头中包含服务\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">器响应的 Cookie 信息。请求头如下\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">GET / HTTP/1.0\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">HOST: itbilu.com\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Cookie: UserID=itbilu</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><br></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 29, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (190, '一个页面从输入 URL 到页面加载显示完成，这个过程 中都发生了什么', 1, '2023-02-09 15:01:35', 0, '一个页面从输入 URL 到页面加载显示完成，这个过程\n中都发生了什么', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">01.浏览器查找域名对应的 IP 地址(DNS 查询：浏览器缓存-&gt;系统缓存-&gt;路由器缓存-&gt;ISP DNS \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">缓存-&gt;根域名服务器)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">02.浏览器向 Web 服务器发送一个 HTTP 请求（TCP 三次握手）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">03.服务器 301 重定向（从 http://example.com 重定向到 http://www.example.com）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">04.浏览器跟踪重定向地址，请求另一个带 www 的网址\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">05.服务器处理请求（通过路由读取资源）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">06.服务器返回一个 HTTP 响应（报头中把 Content-type 设置为 \'text/html\'）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">07.浏览器进 DOM 树构建\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">08.浏览器发送请求获取嵌在 HTML 中的资源（如图片、音频、视频、CSS、JS 等）</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">09.浏览器显示完成页面\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">10.浏览器发送异步请求</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 29, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (191, '你知道的 HTTP 请求方式有几种', 1, '2023-02-09 15:02:02', 0, '你知道的 HTTP 请求方式有几种', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">HTTPRequestMethod 共计 17 种\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1. GET 请求指定的页面信息，并返回实体主体。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2. HEAD 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3. POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4. PUT 从客户端向服务器传送的数据取代指定的文档的内容。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5. DELETE 请求服务器删除指定的页面。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">6. CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">7. OPTIONS 允许客户端查看服务器的性能。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">8. TRACE 回显服务器收到的请求，主要用于测试或诊断。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">9. PATCH 实体中包含一个表，表中说明与该 URI 所表示的原内容的区别。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">10. MOVE 请求服务器将指定的页面移至另一个网络地址。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">11. COPY 请求服务器将指定的页面拷贝至另一个网络地址。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">12. LINK 请求服务器建立链接关系。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">13. UNLINK 断开链接关系。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">14. WRAPPED 允许客户端发送经过封装的请求。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">15. LOCK 允许用户锁定资源，比如可以再编辑某个资源时将其锁定，以防别人同时对其进\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">行编辑。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">16. MKCOL 允许用户创建资源\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">17. Extension-mothed 在不改动协议的前提下，可增加另外的方法</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 29, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (192, '描述一下 HTTP 的请求过程与原理', 1, '2023-02-09 15:02:17', 0, 'http 请求的过程：域名解析 --> 发起 TCP 的 3 次握手 --> 建立 TCP 连接后发起 http 请求 -\n->服务器响应 http 请求，浏览器得到 html 代码 -->浏览器解析 html 代码，并请求 html 代码\n中的资源（如 js、css、图片等） --> 浏览器对页面进行渲染呈现给用户\n请求原理：HTTP 协议是应用层的一种协议，是一种 C/S 架构服务，基于 TCP/IP 协议来通信，\n监听在 TCP 的 80 端口上，HTTP 协议实现的是客户端可以向服务端获得 web 资源', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">http 请求的过程：域名解析 --&gt; 发起 TCP 的 3 次握手 --&gt; 建立 TCP 连接后发起 http 请求 -\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">-&gt;服务器响应 http 请求，浏览器得到 html 代码 --&gt;浏览器解析 html 代码，并请求 html 代码\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">中的资源（如 js、css、图片等） --&gt; 浏览器对页面进行渲染呈现给用户\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">请求原理：HTTP 协议是应用层的一种协议，是一种 C/S 架构服务，基于 TCP/IP 协议来通信，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">监听在 TCP 的 80 端口上，HTTP 协议实现的是客户端可以向服务端获得 web 资源</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 29, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (193, 'https 有几次握手和挥手？https 的原理什么是', 1, '2023-02-09 15:02:39', 0, 'https 有几次握手和挥手？https 的原理什么是', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">https 是 3 次握手和 4 次挥手，和 http 是一样的。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">原理：https 在传输数据前需要客户端(浏览器)与服务器(网站)之间进行一次握手,在握手过程中\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">将确立双方加密传输数据的密码信息.TLS/SSL 协议是一套加密传输协议,使用了非对称加密,对称\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">加密,以及 HASH 算法，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">https 之所以安全：因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">改信息，而如果使用 HTTPS，密钥在你和终点站才有。https 之所以比 http 安全，是因为他利\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">用 ssl/tls 协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">传递等。保障了传输过程的安全性</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 29, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (194, '什么是 TCP 连接的三次握手', 1, '2023-02-09 15:03:08', 0, 'TCP 是因特网中的传输层协议，使用三次握手协议建立连接，完成三次握手，客户\n端与服务器开始传送数据。', 23, '<div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">连接建立:\n</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"> <spanyes\';font-size:10.56pt;font-family:等线;color:rgb(51,51,51);\">TCP 是因特网中的传输层协议，使用三次握手协议建立连接，<spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">完成三次握手，客户\n</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.56pt;font-family:等线;color:rgb(51,51,51);\"></spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">端与服务器开始传送数据。\n</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(51,51,51);\">第一次握手：建立连<spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">接时，客户端发送 syn 包（syn=j）到服务器，并进入 SYN_SENT\n</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.56pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(51,51,51);\">状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。\n</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(51,51,51);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送\n</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；\n</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包\n</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">ACK(ack=k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状\n</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">态，完成三次握手。</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">TCP 协议的优缺点：\n</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">优点：TCP 发送的包有序号，对方收到包后要给一个反馈，如果超过一定时间还没收到反\n</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">馈就自动执行超时重发，因此 TCP 最大的优点是可靠。</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">缺点：很简单，就是麻烦，如果数据量比较小的话建立连接的过程反而占了大头，不\n</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">断地重发也会造成网络延迟，因此比如视频聊天通常就使用 UDP，因为丢失一些包也没关\n</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\">系，速度流畅才是重要的。</spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.56pt;font-family:等线;color:rgb(0,0,0);\"></div>', 29, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (195, '为什么 TCP 连接需要三次握手四次挥手', 1, '2023-02-09 15:03:54', 0, '为什么 TCP 连接需要三次握手四次挥手', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">为什么是三次握手？\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">为了防止已失效的连接请求报文段突然有送到了服务器，因而产生错误,假设两次握手时，客户\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">发出的第一个请求连接报文段在某一网络节点长时间滞留，以致延误到连接释放后才到达服务\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">器。服务器收到失效的连接请求报文段后，认为是客户又发出一次新的连接请求。于是向客户\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">发送确认报文段，同意建立连接，此时在假定两次握手的前提下，连接建立成功。这样会导致\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">服务器的资源白白浪费\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">为什么是四次挥手？\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">TCP 协议是全双工通信，这意味着客户端和服务器端都可以向彼此发送数据，所以关闭连接是\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">双方都需要确认的共同行为，假设是三次挥手时，首先释放了客户到服务器方向的连接，此时\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">TCP 连接处于半关闭状态，这时客户不能向服务器发送数据，而服务器还是可以向客户发送数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">据。如果此时客户收到了服务器的确认报文段后，就立即发送一个确认报文段，这会导致服务\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">器向客户还在发送数据时连接就被关闭。这样会导致客户没有完整收到服务器所发的报文段</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 29, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (196, 'TCP 与 UDP 的区别有哪些', 1, '2023-02-09 15:04:22', 1, 'TCP 与 UDP 的区别有哪些', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的传输层通信协议\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">UDP(User Datagram Protocol 用户数据报协议）是 OSI（Open System Interconnection，开放式\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">TCP 是面向连接的传输控制协议，而 UDP 提供了无链接的数据报服务//类似电话与短信\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">TCP 面向连接，提供可靠的数据服务\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">TCP 首部开销 20 字节,UDP 首部开销 8 字节\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">TCP 逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">UDP 没有拥塞机制，因此网络出现拥堵不会使源主机的发送效率降低（有利于实时会议视频\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">等）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">TCP 的连接只能是点到点的,UDP 支持一对一，多对一，多对多的交互通信</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 29, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (197, 'HTTP2 / HTTP1 之间的区别是什么', 1, '2023-02-09 15:05:02', 0, 'HTTP2 / HTTP1 之间的区别是什么', NULL, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）http2 采用二进制格式而非文本格式，比起文本格式，二进制格式解析起来更加高效，并且\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">错误少\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）http2 是完全的多路复用，非有序并阻塞的----只需要一个连接即可实现并行，多路复用的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">意思是它能同时处理多个消息的请求和响应，http1 是一个连接一次只能提交一个请求的效率\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">比较高，多了就会变慢</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）使用报头压缩，http2 降低了开销，http1 的消息头很大冗余,http2 是将消息头中的不同的部\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">分分别用不用的索引进行表示，且会用哈夫曼编码压缩字符串，最后封装成 frame\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4）http2 让服务器可以将响应主动”推送”到客户端缓存中，HTTP2 中服务器会主动将资源推\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">送给客户端，例如把 js 和 css 文件主动推送给客户端而不用客户端解析 HTML 后请求再响应</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', NULL, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (198, '介绍一下 websocket', 1, '2023-02-09 15:05:18', 0, '介绍一下 websocket', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">websocket 是一种网络通信协议，是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通信\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的协议，这个对比着 http 协议来说，http 协议是一种无状态的、无连接的、单向的应用层协\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">议，通信请求只能由客户端发起，服务端对请求做出应答处理。http 协议无法实现服务器主动\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">向客户端发起消息，Websocket 连接允许客户端和服务器之间进行全双工通信，以便任一方都\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">可以通过建立的连接将数据推送到另一端。WebSocket 只需要建立一次连接，就可以一直保持\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">连接状态</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 29, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (199, '浏览器如何加载页面的，script 脚本阻塞有什么解决办 法，defer 和 async 的区别是什么', 1, '2023-02-09 15:05:43', 0, '浏览器如何加载页面的，script 脚本阻塞有什么解决办\n法，defer 和 async 的区别是什么', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">从浏览器地址栏的请求链接开始，浏览器通过 DNS 解析查到域名映射的 IP 地址，成功之后浏览器端向此 IP 地\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">址取得连接，成功连接之后，浏览器端将请求信息通过 HTTP 协议向此 IP 地址所在服务器发起请求，服务器接</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">收到请求之后等待处理，最后向浏览器端发回响应，此时在 HTTP 协议下，浏览器从服务器接收到 text/html 类</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">型的代码，浏览器开始显示此 html，并获取其中内嵌资源地址，然后浏览器再发起请求来获取这些资源，并在\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">浏览器的 html 中显示\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1 </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">推迟加载（延迟加载）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">如果页面初始的渲染并不依赖于 js 或者 CSS 可以用推迟加载，就是最后在加载 js 和 css，把引用外部文件的代\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">码写在最后\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2 </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">defer 延迟加载\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">&lt;script src=\"\" defer&gt;&lt;/script&gt;在文档解析完成开始执行，并且在 DOMContentLoaded 事件之前执行完成，会按\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">照他们在文档出现的顺序去下载解析。效果和把 script 放在文档最后&lt;/body&gt;之前是一样的。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">注：defer 最好用在引用外部文件中使用，用了 defer 不要使用 document.write()方法;使用 defer 时最好\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">不要请求样式信息，因为样式表可能尚未加载，浏览器会禁止该脚本等待样式表加载完成，相当于样式表阻塞\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">脚本执行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3 </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">异步加载\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">async 异步加载：就是告诉浏览器不必等到加载完外部文件，可以边渲染边下载，什么时候下载完成什么时候执\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">行。&lt;script type=\"text/javascript\" src=\"a.js\" async&gt;&lt;/script&gt;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">defer 和 async 的区别：&lt;script async src=\"example.js\"&gt;&lt;/script&gt;有了 async 属性，表示后续文档的加载和渲染\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">与 js 脚本的加载和执行是并行进行的，即异步执行；&lt;script defer src=\"example.js\"&gt;&lt;/script&gt;\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">有了 defer 属性，加载后续文档的过程和 js 脚本的加载(此时仅加载不执行)是并行进行的(异步)，js 脚本的执行\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">需要等到文档所有元素解析完成之后，DOMContentLoaded 事件触发执行之前</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div>', 29, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (200, '拆解一下 URL 的各个部分，分别是什么意思', 1, '2023-02-09 15:06:39', 2, '拆解一下 URL 的各个部分，分别是什么意思', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">例如：scheme://host:port/path?query#fragment\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">1 </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">.scheme:通信协议，常用的 http,ftp,maito 等\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">2 </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">.host:主机，服务器(计算机)域名系统 (DNS) 主机名或 IP 地址\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">3 </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">.port:端口号，整数，可选，省略时使用方案的默认端口，如 http 的默认端口为 80\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">4 </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">.path:路径，由零或多个\"/\"符号隔开的字符串，一般用来表示主机上的一个目录或文件地址\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">5 </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">.query:查询，可选，用于给动态网页传递参数，可有多个参数，用\"&amp;\"符号隔开，每个参数的名\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">和值用\"=\"符号隔开\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">6 </spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">.fragment:信息片断，字符串，用于指定网络资源中的片断。例如一个网页中有多个名词解释，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">可使用 fragment 直接定位到某一名词解释。(也称为锚点)</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div>', 29, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (201, 'Ajax 解决浏览器缓存问题？', 1, '2023-02-09 15:07:02', 2, 'Ajax 解决浏览器缓存问题？', 23, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">1、在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(\"If-Modified-Since\",\"0\")。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">2、在 ajax 发送请求前加上 anyAjaxObj.setRequestHeader(\"Cache-Control\",\"no-cache\")。<br><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">3、在 URL 后面加上一个随机数：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">\"fresh=\" + Math.random();。</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">4、在 URL 后面加上时间戳：</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"><span style=\"font-size: var(--font-size); color: var(--el-text-color-regular); text-align: initial;\">\"nowtime=\" + new Date().getTime();。</span></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">5、如果是使用 jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有 ajax 都\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\">会执行这条语句就是不需要保存缓存记录&nbsp;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(74,74,74);\"></div>', 28, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (202, ' node.js 有没有了解，它有什么特点，适合做什么业务', 1, '2023-02-09 15:09:40', 0, ' node.js 有没有了解，它有什么特点，适合做什么业 务', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">你可以这样回答（提示：回答该问题建议：请理解内容，使用自己的语言表达为最佳的回答\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">哦！）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">node.js...它既是开发平台, 也是运行环境, 也是个新的语言...它本身是基于 google 的 javascript \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">v8 引擎开发的, 因此在编写基于它的代码的时候使用 javascript 语言. 但是又不同于传统概念的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">javascript...它的服务端功能以及部分客户端功能必须在服务端运行, 所以它实际上是一种在服务\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">端的开发+运行的 javascript 语言. 它本身可以作为 HTTP Server, 也可以当作 TCP Server 用.\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">他是一个 javascript 运行环境，依赖于 Chrome V8 引擎进行代码解释\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">特征：单线程、事件驱动、非阻塞 I/O，轻量，可伸缩，适于实时数据交互应用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">单进程，单线程 (一个应用程序对应一个进程, 一个进程下面会有多个线程, 每个线程用于处理\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">任务..)\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">node 无法直接渲染静态页面，提供静态服务\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">node 没有根目录的概念\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">node 必须通过路由程序指定文件才能渲染文件\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">node 比其他服务端性能更好，速度更快\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Nodejs 是单线程，非阻塞 I/O，事件驱动，它的特点决定了它适合做一些大量 I/O 的东西，比\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">如，聊天室，表单提交等不需要大量计算的功能。做一些微信后端开发，或者做消息系统等。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">可以整个项目用，也可以根据它的特点在某个模块使用，比如 socketio，打造一个消息系统等</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (203, 'npm 作用是什么，有什么好处', 1, '2023-02-09 15:10:22', 0, '允许用户从 NPM 服务器下载别人编写的第三方包到本地使用\n允许用户将自己编写的包或命令行程序上传到 NPM 服务器供别人使用\n通过 NPM，你可以安装和管理项目的依赖，并且能够指明依赖项的具体版本号，可以通过\npackage.json 文件来管理项目信息，配置脚本', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">允许用户从 NPM 服务器下载别人编写的第三方包到本地使用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">允许用户将自己编写的包或命令行程序上传到 NPM 服务器供别人使用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">通过 NPM，你可以安装和管理项目的依赖，并且能够指明依赖项的具体版本号，可以通过\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">package.json 文件来管理项目信息，配置脚本</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (204, '常用的 npm 指令有哪些', 1, '2023-02-09 15:10:35', 0, 'npm init / npm install / npm remove / npm uninstall / npm config set / npm search', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">npm init / npm install / npm remove / npm uninstall / npm config set / npm search</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (205, 'module.exports 和 exports 的区别', 1, '2023-02-09 15:10:47', 0, '本质上是无区别的, 最终暴露给外部的都是 module.exports, exports 只是 module.exports 的辅\n助工具, 他们是相等的,\n所以既用 exports.xxx 也用 module.exports, 则之前的 exports.xxx 会被覆盖掉', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">本质上是无区别的, 最终暴露给外部的都是 module.exports, exports 只是 module.exports 的辅\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">助工具, 他们是相等的,\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">所以既用 exports.xxx 也用 module.exports, 则之前的 exports.xxx 会被覆盖掉</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (206, 'session 和 cookie 的作用, 以及区别是什么', 1, '2023-02-09 15:11:09', 0, 'session 是区别于数据库存在的一种服务器临时存储技术, 它主要存储一些无需持久化的数据,\n比如临时的登录状态信息等\ncookie 是存在于浏览器上的一种浏览器本地存储的方式, 同域名下的 cookie 不同标签页可以共\n享, 默认过期时间是浏览器关闭时, 而且在进行 http 请求时, 会自动带上浏览器全部的 cookie\n发给后台, 后台也可以获取 cookie, 设置可以在响应时, 向浏览器中设置 cookie。', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">session 是区别于数据库存在的一种服务器临时存储技术, 它主要存储一些无需持久化的数据,\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">比如临时的登录状态信息等\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">cookie 是存在于浏览器上的一种浏览器本地存储的方式, 同域名下的 cookie 不同标签页可以共\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">享, 默认过期时间是浏览器关闭时, 而且在进行 http 请求时, 会自动带上浏览器全部的 cookie\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">发给后台, 后台也可以获取 cookie, 设置可以在响应时, 向浏览器中设置 cookie。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (207, '', 1, '2023-02-09 15:11:30', 1, '1）所有同步任务都在主线程上执行，形成一个执行栈\n2）当主线程中的执行栈为空时，检查事件队列是否为空，如果为空，则继续检查；如不为空，\n则执行 3\n3）取出任务队列的首部，加入执行栈\n4）执行任务\n5）检查执行栈，如果执行栈为空，则跳回第 2 步；如不为空，则继续检查', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）所有同步任务都在主线程上执行，形成一个执行栈\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）当主线程中的执行栈为空时，检查事件队列是否为空，如果为空，则继续检查；如不为空，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">则执行 3\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）取出任务队列的首部，加入执行栈\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4）执行任务\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5）检查执行栈，如果执行栈为空，则跳回第 2 步；如不为空，则继续检查</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (208, 'node 和 前端项目怎么解决跨域的', 1, '2023-02-09 15:11:54', 0, '设置 CORS 或者 使用使用 CORS 模块', 22, '<div><spanyes\';font-size:12pt;font-family:等线;color:rgb(0,0,0);\">设置 CORS 或者 使用使用 CORS 模块</spanyes\';font-size:12pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (209, 'node 的优点是什么？缺点是什么', 1, '2023-02-09 15:12:12', 0, 'node 的优点是什么？缺点是什么', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">优点：&lt;1 高并发（最主要的一个优点）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">&lt;2 适合 I/O 密集型应用\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">缺点：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1. 不适合 CPU 密集型应用；CPU 密集型应用给 Node 带来的挑战主要是：由于 JavaScript\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">单线程的原因，如果有长时间运行的计算（比如大循环），将会导致 CPU 时间片不能释\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">放，使得后续 I/O 无法发起；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">解决方案：分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞 I/O 调用的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">发起；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2. 只支持单核 CPU，不能充分利用 CPU\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3. 可靠性低，一旦代码某个环节崩溃，整个系统都崩溃\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">原因：单进程，单线程\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">解决方案：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）Nnigx 反向代理，负载均衡，开多个进程，绑定多个端口；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">（</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）开多个进程监听同一个端口，使用 cluster 模块；\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4. 开源组件库质量参差不齐，更新快，向下不兼容\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5. Debug 不方便，错误没有 stack trace&nbsp;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (210, 'commonJS 中的 require/exports 和 ES6 中import/export 的区别是什么', 1, '2023-02-09 15:12:36', 0, 'commonJS 模块的重要特性是加载时执行，及脚本代码在 require 的时候，就会全部执行。一旦\n出现某个模块被“循环加载”就只输出已经执行的部分，还没有执行的部分是不输出的\nES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会缓存，而是成为一\n个指向被加载模块的引用,import/export 最终都是编译为 require/exports 来执行的', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">commonJS 模块的重要特性是加载时执行，及脚本代码在 require 的时候，就会全部执行。一旦\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">出现某个模块被“循环加载”就只输出已经执行的部分，还没有执行的部分是不输出的\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">ES6 模块是动态引用，如果使用 import 从一个模块加载变量，那些变量不会缓存，而是成为一\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">个指向被加载模块的引用,import/export 最终都是编译为 require/exports 来执行的</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (211, '简述同步和异步的区别，如何避免回调地狱，node 的 异步问题是如何解决的', 1, '2023-02-09 15:13:06', 2, '同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为\n异步方法调用一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而异步方法\n通常会在另外一个线程中，整个过程，不会阻碍调用者的工作\n避免回调地狱：\n1）Promise\n2）async/await\n3）generator\n4）事件发布/监听模式\n模块化: 将回调函数转换为独立的函数\n使用流程控制库，例如 aync\n使用 Promise\n使用 aync/await(参考 Async/Await 替代 Promise 的 6 个理由)', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">异步方法调用一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而异步方法\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">通常会在另外一个线程中，整个过程，不会阻碍调用者的工作\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">避免回调地狱：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）Promise\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）async/await\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）generator\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4）事件发布/监听模式\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">模块化: 将回调函数转换为独立的函数\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用流程控制库，例如 aync\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用 Promise\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用 aync/await(参考 Async/Await 替代 Promise 的 6 个理由)</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (212, 'npm i 与 npm install 之间的细小区别', 1, '2023-02-09 15:13:39', 1, '1）用 npm i 安装的模块无法用 npm uninstall 卸载，需要用 npm uninstall i 命令\n2）npm i 会帮助检测与当前 node 版本最匹配的 npm 包 版本号，并匹配出来相互依赖的 npm\n包应该提升的版本号\n3）部分 npm 包在当前 node 版本下无法使用，必须使用建议版本\n4）安装报错时 intall 肯定会出现 npm-debug.log 文件，npm i 不一定', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）用 npm i 安装的模块无法用 npm uninstall 卸载，需要用 npm uninstall i 命令\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）npm i 会帮助检测与当前 node 版本最匹配的 npm 包 版本号，并匹配出来相互依赖的 npm\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">包应该提升的版本号\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）部分 npm 包在当前 node 版本下无法使用，必须使用建议版本\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4）安装报错时 intall 肯定会出现 npm-debug.log 文件，npm i 不一定</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (213, 'dependencies 和 devDependencies 两者区别', 1, '2023-02-09 15:14:03', 0, 'dependencies 和 devDependencies 两者区别', 22, '<div><spanyes\';font-size:12pt;font-family:宋体;color:rgb(0,0,0);\"> </spanyes\';font-size:12pt;font-family:宋体;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">npm 生成的 package.json 文件中，有 devDependencies 和 dependencies 两个环境</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">devDependencies 用于开发环境（本地）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">dependencies 用于生产环境（发布）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">-save //会把依赖包名称添加到 package.json 文件 dependencies 下\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">-save-dev //则添加到 package.json 文件 devDependencies 下\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">devDependencies 下列出的模块，是我们开发时用的依赖项，像一些进行单元测试之类的包\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//webpack，gulp 等打包工具，这些都是我们开发阶段使用的，代码提交线上时，不需要这些\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">工具，所以我们将它放入 devDependencies 即可\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">dependencies 下的模块，则是我们生产环境中需要的依赖，即正常运行该包时所需要的依赖项\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">//像 jQuery 库文件以及 vue 插件 vue-awesome-swiper，vue-router 路由等是在打包之后继续\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">用到的，所以放到 dependencies 里面\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">\"dependencies\"：应用程序在生产中需要这些包,即项目上线后所依赖的环境。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">\"devDependencies\"：这些包仅用于开发和测试,即开发中所需要的产品中就不需要。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (214, 'Express 和 koa 有什么关系，有什么区别', 1, '2023-02-09 15:15:04', 0, 'Express 和 koa 有什么关系，有什么区别', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">你可以这样回答（提示：回答该问题建议：请理解内容，使用自己的语言表达为最佳的回答\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">哦！）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">架。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">并极大地提升错误处理的效率。&nbsp;</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web \n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">应用变得得心应手。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">koa 是一个比 express 更精简，使用 node 新特性的中间件框架，相比之前 express 就是一个庞\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">大的框架如果你喜欢 DIY 很潮，可以考虑 koa，他有足够的的扩展和中间间，而且自己写很简\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">单。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">如果你想简单点，找一个框架啥都有，那么先 express</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (215, 'mysql 和 mongoDB 有什么区别', 1, '2023-02-09 15:15:32', 0, 'mysql 和 mongoDB 有什么区别', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">你可以这样回答：（提示：回答该问题建议：请理解内容，使用自己的语言表达为最佳的回答\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">哦！）\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">MySQL\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）. 关系型数据库\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）. 在不同的引擎上有不同 的存储方式。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）. 查询语句是使用传统的 sql 语句，拥有较为成熟的体系，成熟度很高。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4）. 开源数据库的份额在不断增加，mysql 的份额页在持续增长。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5）. 缺点就是在海量数据处理的时候效率会显著变慢。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">MongoDB\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">非关系型数据库（Nosql）,属于文档型数据库。先解释一下文档的数据库，即可以存放 xml、\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">json、bson（即 Binary-JSON）类型系那个的数据。这些数据具备自述性（self-describing），\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">呈现分层的树状数据结构。数据结构由键值(key=&gt;value)对组成。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">MongoDB 是由 C++语言编写的，主要是在为 WEB 应用提供可扩展的高性能数据存储解决方\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">案。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">存储方式：虚拟内存+持久化。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">查询语句：是独特的 Mongodb 的查询方式。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">适合场景：事件的记录，内容管理或者博客平台等等。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">架构特点：可以通过副本集，以及分片来实现高可用。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">数据处理：数据是存储在硬盘上的，只不过需要经常读取的数据会被加载到内存中，将数据存\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">储在物理内存中，从而达到高速读写。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">成熟度与广泛度：新兴数据库，成熟度较低，Nosql 数据库中最为接近关系型数据库，比较完\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">善的 DB 之一，适用人群不断在增长。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">MongoDB 的优势：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> 1）. 快速！在适量级的内存的 Mongodb 的性能是非常迅速的，它将热数据存储在物理内存\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">中，使得热数据的读写变得十分快\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> 2）. 高扩展。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）. 自身的 Failover 机制。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4）. json 的存储格式。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5）. 内置 GridFS，支持大容量的存储。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">6）. 内置 Sharding，分片简单。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">7）. 高扩展。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">8）. 海量数据下，性能优越。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">9）. 支持自动故障恢复（复制集）。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">MongoDB 的缺陷：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> 1）. 不支持事务操作\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"> 2）. 占用空间过大</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）. MongoDB 没有如 MySQL 那样成熟的维护工具。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4）. 无法进行关联表查询，不适用于关系多的数据。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">5）. 复杂聚合操作通过 mapreduce 创建，速度慢\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">6）. 模式自由， 自由灵活的文件存储格式带来的数据错误\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">7）. MongoDB 没有如 MySQL 那样成熟的维护工具，这对于开发和 IT 运营都是个值得注意的地\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">方</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (216, '事件的订阅和发布的设计模式是什么', 1, '2023-02-09 15:15:42', 0, '其实就是收集事件名, 对应的方法体, 当触发对应事件名时, 把事件名对应的所有方法体调用执\n行一遍', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">其实就是收集事件名, 对应的方法体, 当触发对应事件名时, 把事件名对应的所有方法体调用执\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">行一遍</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (217, 'express 中 Router 的作用', 1, '2023-02-09 15:15:58', 0, '* express.Router 可以认为是一个微型的只用来处理中间件与控制器的 app，它拥有和 app 类\n似的方法，例如 get、post、all、use 等等。\n* router 它解决了直接把 app 暴露给其它模块使得 app 有被滥用的风险, 优化路由管理', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">* express.Router 可以认为是一个微型的只用来处理中间件与控制器的 app，它拥有和 app 类\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">似的方法，例如 get、post、all、use 等等。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">* router 它解决了直接把 app 暴露给其它模块使得 app 有被滥用的风险, 优化路由管理</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (218, 'npm 自定义命令在哪里配置', 1, '2023-02-09 15:16:07', 0, '在运行命令时, 所在目录下的 package.json 中的 scripts 字段对应的位置进行配置\n* key 是 npm run 要执行的自定义命令的名字\n* value 是 执行自定义命令时, 真正对应的 cmd 命令', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">在运行命令时, 所在目录下的 package.json 中的 scripts 字段对应的位置进行配置\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">* key 是 npm run 要执行的自定义命令的名字\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">* value 是 执行自定义命令时, 真正对应的 cmd 命令</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (219, 'express 优点、缺点', 1, '2023-02-09 15:16:20', 3, 'Express 的优点是线性逻辑：路由和中间件完美融合，通过中间件形式把业务逻辑细分，简\n化，一个请求进来经过一系列中间件\n处理后再响应给用户，再复杂的业务也是线性了，清晰明了。\n缺点：Express 是基于 callback 来组合业务逻辑。Callback 有两大硬伤，一是不可组合，二是\n异常不可捕获。', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">Express 的优点是线性逻辑：路由和中间件完美融合，通过中间件形式把业务逻辑细分，简\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">化，一个请求进来经过一系列中间件\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">处理后再响应给用户，再复杂的业务也是线性了，清晰明了<spanyes\';font-size:12pt;font-family:等线;color:rgb(0,0,0);\">。\n</spanyes\';font-size:12pt;font-family:等线;color:rgb(0,0,0);\"></spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">缺点：Express 是基于 callback 来组合业务逻辑。Callback 有两大硬伤，一是不可组合，二是\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">异常不可捕获。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (220, '什么是中间件', 1, '2023-02-09 15:16:32', 3, '中间件其实就是一个个的函数, 当调用 next 时, 才会执行下一个中间件函数 Express 是一个自身\n功能极简，完全是路由和中间件\n构成一个 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件函数。封装\n了一些或许复杂但肯定是通用的功能,\n非内置的中间件需要通过安装后，require 到文件就可以运行', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">中间件其实就是一个个的函数, 当调用 next 时, 才会执行下一个中间件函数 Express 是一个自身\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">功能极简，完全是路由和中间件\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">构成一个 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件函数。封装\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">了一些或许复杂但肯定是通用的功能,\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">非内置的中间件需要通过安装后，require 到文件就可以运行</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (221, '为什么要进行模块化', 1, '2023-02-09 15:16:46', 18, '目前前端的开发形势就是模块化和组件化；从软件工程学分析来说就是有了更好的可维护性、\n可复用性等好处；但是前端的主要语言 js 在 es6\n之前却没有模块化功能，之前有使用 require.js 和 sea.js 但是推出 es6 的模块化之后，es6 的模\n块化使用形式基本统一', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">目前前端的开发形势就是模块化和组件化；从软件工程学分析来说就是有了更好的可维护性、\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">可复用性等好处；但是前端的主要语言 js 在 es6\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">之前却没有模块化功能，之前有使用 require.js 和 sea.js 但是推出 es6 的模块化之后，es6 的模\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">块化使用形式基本统一</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (222, '谈谈你对 AMD 和 CMD 的理解', 1, '2023-02-09 15:17:10', 0, '谈谈你对 AMD 和 CMD 的理解', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">AMD：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">AMD 推崇依赖前置，在定义模块的时候就要声明其依赖的模块\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">同样都是异步加载模块，AMD 在加载模块完成后就会执行该模块，所有模块都加载执行完后会\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">进入 require 的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">才执行。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">CMD：\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">CMD 推崇就近依赖，只有在用到某个模块的时候再去 require\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">CMD 加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">辑，遇到 require 语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">的。\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">特点：AMD 用户体验好，因为没有延迟，依赖模块提前执行了；CMD 性能好，因为只有用户\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">需要的时候才执行。</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (223, 'node 怎么跟 MongoDB 建立连接', 1, '2023-02-09 15:17:24', 2, '1）引入 mongoose\n2）使用 mongoose.connect()方法连接到 MongoDB 数据库\n3）监听连接是否成功\n4）然后通过 node，书写接口，对数据库进行增删改查', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1）引入 mongoose\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2）使用 mongoose.connect()方法连接到 MongoDB 数据库\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3）监听连接是否成功\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4）然后通过 node，书写接口，对数据库进行增删改查</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (224, '请介绍一下 require 的模块加载机制', 1, '2023-02-09 15:17:37', 41, '这道题基本上就可以了解到面试者对 Node 模块机制的了解程度基本上面试提到\n1、先计算模块路径\n2、如果模块在缓存里面，取出缓存\n3、加载模块\n4、输出模块的 exports 属性即可', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">这道题基本上就可以了解到面试者对 Node 模块机制的了解程度基本上面试提到\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1、先计算模块路径\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2、如果模块在缓存里面，取出缓存\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3、加载模块\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4、输出模块的 exports 属性即可</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');
INSERT INTO `article` VALUES (225, '内置的 fs 模块架构是什么样子的', 1, '2023-02-09 15:17:52', 203, 'fs 模块主要由下面几部分组成:\n1) POSIX 文件 Wrapper,对应于操作系统的原生文件操作\n2) 文件流 fs.createReadStream 和 fs.createWriteStream\n3) 同步文件读写,fs.readFileSync 和 fs.writeFileSync\n4) 异步文件读写, fs.readFile 和 fs.writeFile', 22, '<div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">fs 模块主要由下面几部分组成:\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">1) POSIX 文件 Wrapper,对应于操作系统的原生文件操作\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">2) 文件流 fs.createReadStream 和 fs.createWriteStream\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">3) 同步文件读写,fs.readFileSync 和 fs.writeFileSync\n</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div><div><spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\">4) 异步文件读写, fs.readFile 和 fs.writeFile</spanyes\';font-size:10.08pt;font-family:等线;color:rgb(0,0,0);\"></div>', 30, 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a');

-- ----------------------------
-- Table structure for article_comment
-- ----------------------------
DROP TABLE IF EXISTS `article_comment`;
CREATE TABLE `article_comment`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `article_id` int(11) NULL DEFAULT NULL COMMENT '所属文章',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '内容',
  `user_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '创建人昵称',
  `user_id` int(11) NULL DEFAULT NULL COMMENT '创建人',
  `creation_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `ip` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'ip地址',
  `parent_id` int(11) NULL DEFAULT NULL COMMENT '上级评论Id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 61 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of article_comment
-- ----------------------------
INSERT INTO `article_comment` VALUES (52, 221, '<p>你好！</p>', '游客', 2, '2023-02-23 15:02:07', '172.16.12.251', NULL);
INSERT INTO `article_comment` VALUES (53, 221, '我有点不太好！', '游客', 2, '2023-02-23 15:03:18', '172.16.12.251', 52);
INSERT INTO `article_comment` VALUES (54, 225, '<p>哈哈哈</p>', 'THyo', 1, '2023-02-24 15:30:12', '172.16.12.251', NULL);
INSERT INTO `article_comment` VALUES (55, 225, '真的太棒了！', '游客', 2, '2023-02-24 15:44:43', '172.16.12.251', 54);
INSERT INTO `article_comment` VALUES (56, 225, '213123213', 'THyo', 1, '2023-02-24 15:47:27', '172.16.12.251', 54);
INSERT INTO `article_comment` VALUES (57, 225, '哥哥', '小黑子', 10, '2023-02-24 15:50:22', '172.16.12.251', 54);
INSERT INTO `article_comment` VALUES (58, 225, '<p>哈哈哈哈</p>', 'red', 11, '2023-02-24 16:01:10', '172.16.12.251', NULL);
INSERT INTO `article_comment` VALUES (59, 225, '<p>笑死她了</p>', 'red', 11, '2023-02-24 16:01:23', '172.16.12.251', NULL);
INSERT INTO `article_comment` VALUES (60, 225, '笑死她', 'THyo', 1, '2023-02-24 16:04:23', '172.16.12.251', 59);

-- ----------------------------
-- Table structure for article_home_recommend
-- ----------------------------
DROP TABLE IF EXISTS `article_home_recommend`;
CREATE TABLE `article_home_recommend`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `article_id` int(11) NULL DEFAULT NULL COMMENT '文章id',
  `user_id` int(11) NULL DEFAULT NULL COMMENT '所属用户id',
  `creation_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 45 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of article_home_recommend
-- ----------------------------
INSERT INTO `article_home_recommend` VALUES (42, 26, 1, '2023-02-09 10:20:09');
INSERT INTO `article_home_recommend` VALUES (43, 25, 1, '2023-02-09 10:20:10');
INSERT INTO `article_home_recommend` VALUES (44, 24, 1, '2023-02-09 10:20:11');

-- ----------------------------
-- Table structure for article_label
-- ----------------------------
DROP TABLE IF EXISTS `article_label`;
CREATE TABLE `article_label`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `label_id` int(11) NULL DEFAULT NULL COMMENT '标签id',
  `article_id` int(11) NULL DEFAULT NULL COMMENT '文章id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 447 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of article_label
-- ----------------------------
INSERT INTO `article_label` VALUES (92, 14, 17);
INSERT INTO `article_label` VALUES (93, 21, 17);
INSERT INTO `article_label` VALUES (94, 19, 17);
INSERT INTO `article_label` VALUES (96, 21, 16);
INSERT INTO `article_label` VALUES (97, 20, 16);
INSERT INTO `article_label` VALUES (99, 13, 23);
INSERT INTO `article_label` VALUES (100, 20, 23);
INSERT INTO `article_label` VALUES (110, 19, 18);
INSERT INTO `article_label` VALUES (111, 13, 18);
INSERT INTO `article_label` VALUES (112, 21, 18);
INSERT INTO `article_label` VALUES (118, 21, 24);
INSERT INTO `article_label` VALUES (119, 15, 24);
INSERT INTO `article_label` VALUES (121, 21, 25);
INSERT INTO `article_label` VALUES (123, 21, 26);
INSERT INTO `article_label` VALUES (124, 15, 27);
INSERT INTO `article_label` VALUES (125, 14, 27);
INSERT INTO `article_label` VALUES (128, 15, 28);
INSERT INTO `article_label` VALUES (129, 15, 29);
INSERT INTO `article_label` VALUES (131, 14, 30);
INSERT INTO `article_label` VALUES (132, 14, 31);
INSERT INTO `article_label` VALUES (133, 14, 33);
INSERT INTO `article_label` VALUES (134, 14, 34);
INSERT INTO `article_label` VALUES (135, 14, 35);
INSERT INTO `article_label` VALUES (136, 15, 35);
INSERT INTO `article_label` VALUES (137, 14, 36);
INSERT INTO `article_label` VALUES (138, 14, 37);
INSERT INTO `article_label` VALUES (142, 14, 39);
INSERT INTO `article_label` VALUES (143, 15, 39);
INSERT INTO `article_label` VALUES (147, 21, 38);
INSERT INTO `article_label` VALUES (148, 15, 38);
INSERT INTO `article_label` VALUES (149, 14, 38);
INSERT INTO `article_label` VALUES (150, 15, 40);
INSERT INTO `article_label` VALUES (151, 14, 40);
INSERT INTO `article_label` VALUES (152, 14, 41);
INSERT INTO `article_label` VALUES (153, 14, 42);
INSERT INTO `article_label` VALUES (154, 14, 43);
INSERT INTO `article_label` VALUES (155, 15, 43);
INSERT INTO `article_label` VALUES (156, 14, 44);
INSERT INTO `article_label` VALUES (158, 14, 45);
INSERT INTO `article_label` VALUES (159, 14, 47);
INSERT INTO `article_label` VALUES (160, 15, 47);
INSERT INTO `article_label` VALUES (161, 14, 46);
INSERT INTO `article_label` VALUES (162, 14, 49);
INSERT INTO `article_label` VALUES (163, 15, 49);
INSERT INTO `article_label` VALUES (164, 14, 48);
INSERT INTO `article_label` VALUES (165, 14, 50);
INSERT INTO `article_label` VALUES (166, 15, 50);
INSERT INTO `article_label` VALUES (167, 14, 51);
INSERT INTO `article_label` VALUES (168, 21, 52);
INSERT INTO `article_label` VALUES (169, 21, 53);
INSERT INTO `article_label` VALUES (170, 21, 54);
INSERT INTO `article_label` VALUES (171, 21, 55);
INSERT INTO `article_label` VALUES (172, 21, 56);
INSERT INTO `article_label` VALUES (173, 21, 58);
INSERT INTO `article_label` VALUES (174, 21, 57);
INSERT INTO `article_label` VALUES (175, 21, 59);
INSERT INTO `article_label` VALUES (176, 21, 60);
INSERT INTO `article_label` VALUES (177, 21, 61);
INSERT INTO `article_label` VALUES (178, 21, 62);
INSERT INTO `article_label` VALUES (179, 21, 63);
INSERT INTO `article_label` VALUES (180, 21, 64);
INSERT INTO `article_label` VALUES (181, 21, 65);
INSERT INTO `article_label` VALUES (182, 21, 66);
INSERT INTO `article_label` VALUES (183, 21, 67);
INSERT INTO `article_label` VALUES (184, 21, 68);
INSERT INTO `article_label` VALUES (185, 15, 68);
INSERT INTO `article_label` VALUES (188, 21, 69);
INSERT INTO `article_label` VALUES (189, 15, 69);
INSERT INTO `article_label` VALUES (190, 21, 70);
INSERT INTO `article_label` VALUES (191, 21, 71);
INSERT INTO `article_label` VALUES (192, 21, 72);
INSERT INTO `article_label` VALUES (193, 21, 73);
INSERT INTO `article_label` VALUES (194, 21, 74);
INSERT INTO `article_label` VALUES (195, 21, 75);
INSERT INTO `article_label` VALUES (196, 21, 76);
INSERT INTO `article_label` VALUES (197, 21, 77);
INSERT INTO `article_label` VALUES (198, 21, 78);
INSERT INTO `article_label` VALUES (199, 21, 79);
INSERT INTO `article_label` VALUES (200, 22, 80);
INSERT INTO `article_label` VALUES (201, 22, 81);
INSERT INTO `article_label` VALUES (202, 22, 82);
INSERT INTO `article_label` VALUES (203, 15, 82);
INSERT INTO `article_label` VALUES (204, 22, 83);
INSERT INTO `article_label` VALUES (205, 22, 84);
INSERT INTO `article_label` VALUES (206, 22, 85);
INSERT INTO `article_label` VALUES (207, 22, 86);
INSERT INTO `article_label` VALUES (208, 22, 87);
INSERT INTO `article_label` VALUES (209, 22, 88);
INSERT INTO `article_label` VALUES (210, 22, 89);
INSERT INTO `article_label` VALUES (211, 14, 89);
INSERT INTO `article_label` VALUES (212, 21, 89);
INSERT INTO `article_label` VALUES (213, 22, 90);
INSERT INTO `article_label` VALUES (214, 22, 91);
INSERT INTO `article_label` VALUES (215, 21, 91);
INSERT INTO `article_label` VALUES (218, 22, 92);
INSERT INTO `article_label` VALUES (219, 21, 92);
INSERT INTO `article_label` VALUES (220, 21, 93);
INSERT INTO `article_label` VALUES (221, 15, 93);
INSERT INTO `article_label` VALUES (222, 22, 94);
INSERT INTO `article_label` VALUES (223, 21, 94);
INSERT INTO `article_label` VALUES (225, 22, 95);
INSERT INTO `article_label` VALUES (226, 22, 96);
INSERT INTO `article_label` VALUES (227, 21, 96);
INSERT INTO `article_label` VALUES (228, 21, 97);
INSERT INTO `article_label` VALUES (229, 22, 97);
INSERT INTO `article_label` VALUES (230, 22, 99);
INSERT INTO `article_label` VALUES (231, 21, 99);
INSERT INTO `article_label` VALUES (232, 22, 100);
INSERT INTO `article_label` VALUES (233, 21, 100);
INSERT INTO `article_label` VALUES (234, 22, 98);
INSERT INTO `article_label` VALUES (235, 21, 98);
INSERT INTO `article_label` VALUES (236, 22, 101);
INSERT INTO `article_label` VALUES (237, 21, 101);
INSERT INTO `article_label` VALUES (238, 22, 102);
INSERT INTO `article_label` VALUES (239, 21, 102);
INSERT INTO `article_label` VALUES (240, 22, 103);
INSERT INTO `article_label` VALUES (241, 21, 103);
INSERT INTO `article_label` VALUES (242, 21, 105);
INSERT INTO `article_label` VALUES (243, 22, 105);
INSERT INTO `article_label` VALUES (244, 22, 104);
INSERT INTO `article_label` VALUES (245, 21, 104);
INSERT INTO `article_label` VALUES (246, 22, 106);
INSERT INTO `article_label` VALUES (247, 21, 106);
INSERT INTO `article_label` VALUES (249, 21, 107);
INSERT INTO `article_label` VALUES (250, 23, 108);
INSERT INTO `article_label` VALUES (251, 23, 109);
INSERT INTO `article_label` VALUES (252, 23, 110);
INSERT INTO `article_label` VALUES (253, 21, 110);
INSERT INTO `article_label` VALUES (254, 23, 111);
INSERT INTO `article_label` VALUES (255, 21, 111);
INSERT INTO `article_label` VALUES (256, 23, 112);
INSERT INTO `article_label` VALUES (257, 21, 112);
INSERT INTO `article_label` VALUES (258, 23, 113);
INSERT INTO `article_label` VALUES (259, 21, 113);
INSERT INTO `article_label` VALUES (260, 23, 114);
INSERT INTO `article_label` VALUES (261, 21, 114);
INSERT INTO `article_label` VALUES (262, 21, 115);
INSERT INTO `article_label` VALUES (263, 23, 115);
INSERT INTO `article_label` VALUES (264, 21, 116);
INSERT INTO `article_label` VALUES (265, 23, 116);
INSERT INTO `article_label` VALUES (266, 21, 117);
INSERT INTO `article_label` VALUES (267, 23, 117);
INSERT INTO `article_label` VALUES (272, 21, 118);
INSERT INTO `article_label` VALUES (273, 23, 118);
INSERT INTO `article_label` VALUES (274, 21, 119);
INSERT INTO `article_label` VALUES (275, 23, 119);
INSERT INTO `article_label` VALUES (276, 21, 120);
INSERT INTO `article_label` VALUES (277, 23, 120);
INSERT INTO `article_label` VALUES (278, 21, 121);
INSERT INTO `article_label` VALUES (279, 23, 121);
INSERT INTO `article_label` VALUES (280, 21, 122);
INSERT INTO `article_label` VALUES (281, 23, 122);
INSERT INTO `article_label` VALUES (282, 21, 123);
INSERT INTO `article_label` VALUES (283, 23, 123);
INSERT INTO `article_label` VALUES (284, 21, 124);
INSERT INTO `article_label` VALUES (285, 23, 124);
INSERT INTO `article_label` VALUES (286, 21, 125);
INSERT INTO `article_label` VALUES (287, 23, 125);
INSERT INTO `article_label` VALUES (288, 23, 126);
INSERT INTO `article_label` VALUES (289, 21, 126);
INSERT INTO `article_label` VALUES (290, 21, 127);
INSERT INTO `article_label` VALUES (291, 23, 127);
INSERT INTO `article_label` VALUES (292, 21, 128);
INSERT INTO `article_label` VALUES (293, 23, 128);
INSERT INTO `article_label` VALUES (296, 21, 129);
INSERT INTO `article_label` VALUES (297, 23, 129);
INSERT INTO `article_label` VALUES (298, 23, 130);
INSERT INTO `article_label` VALUES (299, 21, 130);
INSERT INTO `article_label` VALUES (300, 21, 131);
INSERT INTO `article_label` VALUES (301, 23, 131);
INSERT INTO `article_label` VALUES (302, 23, 133);
INSERT INTO `article_label` VALUES (303, 21, 133);
INSERT INTO `article_label` VALUES (304, 23, 132);
INSERT INTO `article_label` VALUES (305, 21, 132);
INSERT INTO `article_label` VALUES (306, 21, 134);
INSERT INTO `article_label` VALUES (307, 23, 134);
INSERT INTO `article_label` VALUES (308, 21, 135);
INSERT INTO `article_label` VALUES (309, 23, 135);
INSERT INTO `article_label` VALUES (310, 21, 136);
INSERT INTO `article_label` VALUES (311, 23, 136);
INSERT INTO `article_label` VALUES (312, 23, 137);
INSERT INTO `article_label` VALUES (313, 21, 137);
INSERT INTO `article_label` VALUES (314, 21, 138);
INSERT INTO `article_label` VALUES (315, 23, 138);
INSERT INTO `article_label` VALUES (316, 23, 139);
INSERT INTO `article_label` VALUES (317, 21, 139);
INSERT INTO `article_label` VALUES (318, 21, 140);
INSERT INTO `article_label` VALUES (319, 23, 140);
INSERT INTO `article_label` VALUES (320, 23, 141);
INSERT INTO `article_label` VALUES (321, 23, 142);
INSERT INTO `article_label` VALUES (322, 21, 142);
INSERT INTO `article_label` VALUES (323, 23, 143);
INSERT INTO `article_label` VALUES (324, 21, 143);
INSERT INTO `article_label` VALUES (325, 23, 144);
INSERT INTO `article_label` VALUES (326, 21, 144);
INSERT INTO `article_label` VALUES (327, 21, 145);
INSERT INTO `article_label` VALUES (328, 23, 145);
INSERT INTO `article_label` VALUES (329, 23, 146);
INSERT INTO `article_label` VALUES (330, 24, 146);
INSERT INTO `article_label` VALUES (331, 21, 146);
INSERT INTO `article_label` VALUES (332, 24, 147);
INSERT INTO `article_label` VALUES (333, 23, 147);
INSERT INTO `article_label` VALUES (334, 21, 147);
INSERT INTO `article_label` VALUES (335, 24, 148);
INSERT INTO `article_label` VALUES (336, 23, 148);
INSERT INTO `article_label` VALUES (337, 21, 148);
INSERT INTO `article_label` VALUES (338, 23, 149);
INSERT INTO `article_label` VALUES (339, 24, 149);
INSERT INTO `article_label` VALUES (340, 21, 149);
INSERT INTO `article_label` VALUES (341, 24, 150);
INSERT INTO `article_label` VALUES (342, 24, 151);
INSERT INTO `article_label` VALUES (343, 23, 151);
INSERT INTO `article_label` VALUES (344, 24, 152);
INSERT INTO `article_label` VALUES (345, 23, 152);
INSERT INTO `article_label` VALUES (346, 24, 154);
INSERT INTO `article_label` VALUES (347, 23, 154);
INSERT INTO `article_label` VALUES (348, 24, 155);
INSERT INTO `article_label` VALUES (349, 23, 155);
INSERT INTO `article_label` VALUES (350, 24, 156);
INSERT INTO `article_label` VALUES (351, 23, 156);
INSERT INTO `article_label` VALUES (352, 24, 153);
INSERT INTO `article_label` VALUES (353, 23, 153);
INSERT INTO `article_label` VALUES (356, 21, 157);
INSERT INTO `article_label` VALUES (357, 24, 157);
INSERT INTO `article_label` VALUES (358, 24, 158);
INSERT INTO `article_label` VALUES (359, 23, 158);
INSERT INTO `article_label` VALUES (360, 24, 159);
INSERT INTO `article_label` VALUES (361, 23, 159);
INSERT INTO `article_label` VALUES (362, 24, 160);
INSERT INTO `article_label` VALUES (363, 23, 160);
INSERT INTO `article_label` VALUES (364, 24, 161);
INSERT INTO `article_label` VALUES (365, 23, 161);
INSERT INTO `article_label` VALUES (366, 23, 162);
INSERT INTO `article_label` VALUES (367, 24, 162);
INSERT INTO `article_label` VALUES (368, 24, 163);
INSERT INTO `article_label` VALUES (369, 23, 163);
INSERT INTO `article_label` VALUES (370, 23, 164);
INSERT INTO `article_label` VALUES (371, 24, 164);
INSERT INTO `article_label` VALUES (372, 24, 165);
INSERT INTO `article_label` VALUES (373, 24, 166);
INSERT INTO `article_label` VALUES (374, 23, 166);
INSERT INTO `article_label` VALUES (375, 24, 167);
INSERT INTO `article_label` VALUES (376, 23, 167);
INSERT INTO `article_label` VALUES (377, 24, 168);
INSERT INTO `article_label` VALUES (380, 24, 169);
INSERT INTO `article_label` VALUES (381, 23, 169);
INSERT INTO `article_label` VALUES (382, 24, 170);
INSERT INTO `article_label` VALUES (383, 23, 170);
INSERT INTO `article_label` VALUES (386, 24, 171);
INSERT INTO `article_label` VALUES (387, 23, 171);
INSERT INTO `article_label` VALUES (388, 24, 172);
INSERT INTO `article_label` VALUES (389, 23, 172);
INSERT INTO `article_label` VALUES (390, 25, 173);
INSERT INTO `article_label` VALUES (391, 25, 174);
INSERT INTO `article_label` VALUES (392, 25, 175);
INSERT INTO `article_label` VALUES (393, 25, 176);
INSERT INTO `article_label` VALUES (394, 25, 177);
INSERT INTO `article_label` VALUES (395, 25, 178);
INSERT INTO `article_label` VALUES (396, 25, 179);
INSERT INTO `article_label` VALUES (397, 25, 182);
INSERT INTO `article_label` VALUES (398, 24, 182);
INSERT INTO `article_label` VALUES (399, 23, 182);
INSERT INTO `article_label` VALUES (400, 21, 182);
INSERT INTO `article_label` VALUES (401, 15, 182);
INSERT INTO `article_label` VALUES (402, 21, 181);
INSERT INTO `article_label` VALUES (403, 25, 181);
INSERT INTO `article_label` VALUES (404, 25, 180);
INSERT INTO `article_label` VALUES (405, 25, 183);
INSERT INTO `article_label` VALUES (406, 21, 184);
INSERT INTO `article_label` VALUES (407, 25, 184);
INSERT INTO `article_label` VALUES (408, 23, 184);
INSERT INTO `article_label` VALUES (411, 25, 185);
INSERT INTO `article_label` VALUES (412, 24, 185);
INSERT INTO `article_label` VALUES (413, 25, 186);
INSERT INTO `article_label` VALUES (414, 25, 187);
INSERT INTO `article_label` VALUES (415, 21, 187);
INSERT INTO `article_label` VALUES (416, 25, 188);
INSERT INTO `article_label` VALUES (418, 25, 189);
INSERT INTO `article_label` VALUES (419, 15, 190);
INSERT INTO `article_label` VALUES (420, 21, 190);
INSERT INTO `article_label` VALUES (421, 25, 190);
INSERT INTO `article_label` VALUES (424, 25, 193);
INSERT INTO `article_label` VALUES (425, 27, 193);
INSERT INTO `article_label` VALUES (426, 27, 192);
INSERT INTO `article_label` VALUES (427, 27, 191);
INSERT INTO `article_label` VALUES (428, 27, 195);
INSERT INTO `article_label` VALUES (429, 27, 196);
INSERT INTO `article_label` VALUES (430, 27, 194);
INSERT INTO `article_label` VALUES (431, 27, 197);
INSERT INTO `article_label` VALUES (432, 27, 198);
INSERT INTO `article_label` VALUES (433, 27, 199);
INSERT INTO `article_label` VALUES (434, 27, 200);
INSERT INTO `article_label` VALUES (435, 27, 201);
INSERT INTO `article_label` VALUES (436, 25, 201);
INSERT INTO `article_label` VALUES (437, 21, 206);
INSERT INTO `article_label` VALUES (438, 15, 206);
INSERT INTO `article_label` VALUES (439, 25, 206);
INSERT INTO `article_label` VALUES (440, 27, 206);
INSERT INTO `article_label` VALUES (441, 21, 207);
INSERT INTO `article_label` VALUES (442, 21, 208);
INSERT INTO `article_label` VALUES (443, 15, 208);
INSERT INTO `article_label` VALUES (444, 27, 208);

-- ----------------------------
-- Table structure for article_label_info
-- ----------------------------
DROP TABLE IF EXISTS `article_label_info`;
CREATE TABLE `article_label_info`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `creation_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `user_id` int(11) NULL DEFAULT NULL COMMENT '所属用户',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 28 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of article_label_info
-- ----------------------------
INSERT INTO `article_label_info` VALUES (13, 'Vue', '2023-01-10 13:13:46', 1);
INSERT INTO `article_label_info` VALUES (14, 'CSS', '2023-01-15 15:18:55', 1);
INSERT INTO `article_label_info` VALUES (15, 'HTML', '2023-01-15 15:18:59', 1);
INSERT INTO `article_label_info` VALUES (16, 'React', '2023-01-15 15:19:09', 1);
INSERT INTO `article_label_info` VALUES (17, 'Nuxt', '2023-01-15 15:19:14', 1);
INSERT INTO `article_label_info` VALUES (18, 'VantUI', '2023-01-15 15:19:31', 1);
INSERT INTO `article_label_info` VALUES (19, 'ElementUI', '2023-01-15 15:19:43', 1);
INSERT INTO `article_label_info` VALUES (20, 'Umi', '2023-01-15 15:19:49', 1);
INSERT INTO `article_label_info` VALUES (21, 'JavaScript', '2023-01-15 15:20:13', 1);
INSERT INTO `article_label_info` VALUES (22, 'JsWebApi', '2023-02-09 13:30:33', 1);
INSERT INTO `article_label_info` VALUES (23, 'JavaScript高级', '2023-02-09 14:08:23', 1);
INSERT INTO `article_label_info` VALUES (24, 'Es6', '2023-02-09 14:30:37', 1);
INSERT INTO `article_label_info` VALUES (25, 'AJAX', '2023-02-09 14:52:54', 1);
INSERT INTO `article_label_info` VALUES (27, 'Http', '2023-02-09 15:03:18', 1);

-- ----------------------------
-- Table structure for article_one_class
-- ----------------------------
DROP TABLE IF EXISTS `article_one_class`;
CREATE TABLE `article_one_class`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `user_id` int(11) NULL DEFAULT NULL COMMENT '所属用户id',
  `icon` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '字体图标',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `creation_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 24 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of article_one_class
-- ----------------------------
INSERT INTO `article_one_class` VALUES (21, 1, 'earth', '前端技术栈', '2023-01-10 13:14:11');
INSERT INTO `article_one_class` VALUES (22, 1, 'houduankaifa', '后端技术栈', '2023-01-15 10:25:26');
INSERT INTO `article_one_class` VALUES (23, 1, 'Exportservices-fill', '计算机网络', '2023-02-09 14:48:46');

-- ----------------------------
-- Table structure for article_two_class
-- ----------------------------
DROP TABLE IF EXISTS `article_two_class`;
CREATE TABLE `article_two_class`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `one_class_id` int(11) NULL DEFAULT NULL COMMENT '一级id',
  `icon` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '字体图标',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标题',
  `creation_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 31 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of article_two_class
-- ----------------------------
INSERT INTO `article_two_class` VALUES (20, 21, 'vue', 'Vue3', '2023-01-10 13:14:21');
INSERT INTO `article_two_class` VALUES (21, 21, 'HTML', 'HTML5', '2023-01-10 13:14:35');
INSERT INTO `article_two_class` VALUES (22, 21, 'css3', 'CSS3', '2023-01-15 10:24:50');
INSERT INTO `article_two_class` VALUES (23, 21, 'bxl-javascript', 'JavaScript', '2023-01-15 10:25:03');
INSERT INTO `article_two_class` VALUES (24, 22, 'java', 'Java', '2023-01-15 10:25:36');
INSERT INTO `article_two_class` VALUES (25, 22, 'bxl-spring-boot', 'SpringBoot2', '2023-01-15 10:26:11');
INSERT INTO `article_two_class` VALUES (26, 22, 'integral-fill1', 'MyBatis', '2023-01-15 10:26:31');
INSERT INTO `article_two_class` VALUES (28, 23, 'dongtai', 'AJAX', '2023-02-09 14:49:56');
INSERT INTO `article_two_class` VALUES (29, 23, 'xinwaizongyewu', 'Http网络知识', '2023-02-09 14:50:34');
INSERT INTO `article_two_class` VALUES (30, 22, 'smile', 'NodeJs', '2023-02-09 15:09:00');

-- ----------------------------
-- Table structure for system_imgs
-- ----------------------------
DROP TABLE IF EXISTS `system_imgs`;
CREATE TABLE `system_imgs`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '名称',
  `url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '地址',
  `type` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '文件类型',
  `creation_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 52 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of system_imgs
-- ----------------------------
INSERT INTO `system_imgs` VALUES (33, 'archive-1.jpg', 'http://image.thyo.xyz/img/8bbc9637-81ea-8da8-7a2e-359c0f38d368', 'jpg', '2022-10-21 08:03:27');
INSERT INTO `system_imgs` VALUES (34, 'home-bakck.png', 'http://image.thyo.xyz/img/df3c311d-5b82-78c1-454e-02e8e9b60fe0', 'png', '2022-10-21 08:03:27');
INSERT INTO `system_imgs` VALUES (35, 'img-1.jpg', 'http://image.thyo.xyz/img/380a267e-35a6-09bf-306a-88fd08da9b8a', 'jpg', '2022-10-21 08:03:27');
INSERT INTO `system_imgs` VALUES (36, 'img-2.jpg', 'http://image.thyo.xyz/img/f4239328-b716-7242-c78b-505cdcc25800', 'jpg', '2022-10-21 08:03:27');
INSERT INTO `system_imgs` VALUES (37, 'img-3.jpg', 'http://image.thyo.xyz/img/e58ea33a-1ec8-ac49-b634-3f0318bb1088', 'jpg', '2022-10-21 08:03:27');
INSERT INTO `system_imgs` VALUES (38, 'img-4.jpg', 'http://image.thyo.xyz/img/e3996e4c-fa43-11f2-ce67-063b050224c2', 'jpg', '2022-10-21 08:03:27');
INSERT INTO `system_imgs` VALUES (39, 'img-5.jpg', 'http://image.thyo.xyz/img/27482807-d03d-5546-c185-6a7078a20a7d', 'jpg', '2022-10-21 08:03:27');
INSERT INTO `system_imgs` VALUES (40, 'thyo-photo-1.jpg', 'http://image.thyo.xyz/img/679eac68-ad79-a547-99b4-15d870568286', 'jpg', '2022-10-21 08:03:27');
INSERT INTO `system_imgs` VALUES (41, 'img_1.jpg', 'http://image.thyo.xyz/img/c2ea7202-932e-e0e8-3393-53c8e69e6aa8', 'jpg', '2022-12-23 10:44:46');
INSERT INTO `system_imgs` VALUES (42, 'img-2.png', 'http://image.thyo.xyz/img/185a0f18-3c83-5e68-1264-ba464ff85a93', 'png', '2022-12-23 10:45:42');
INSERT INTO `system_imgs` VALUES (43, '猫咪1.png', 'http://image.thyo.xyz/img/c941b0f4-743b-ee95-890e-4a2803a8f434', 'png', '2023-01-12 14:47:55');
INSERT INTO `system_imgs` VALUES (51, 'jw204t1jkgyjw204t1jkgy.jpg', 'http://image.thyo.xyz/img/fefae626-6f9f-2463-f12d-837cf381cdc8', 'jpg', '2023-02-21 15:36:49');

-- ----------------------------
-- Table structure for system_menus
-- ----------------------------
DROP TABLE IF EXISTS `system_menus`;
CREATE TABLE `system_menus`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增ID',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '菜单名称',
  `icon` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '菜单图标',
  `router` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '菜单前端路径',
  `router_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '路由名称',
  `file_address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '前端页面文件地址',
  `parent_id` int(11) NULL DEFAULT NULL COMMENT '上级菜单id',
  `creation_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `user_id` int(11) NULL DEFAULT NULL COMMENT '创建人',
  `sort` int(11) NULL DEFAULT NULL COMMENT '排序',
  `type` tinyint(4) NULL DEFAULT NULL COMMENT '类型（1:菜单,2:按钮）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 32 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '菜单列表' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of system_menus
-- ----------------------------
INSERT INTO `system_menus` VALUES (15, '首页', 'House', '/admin', 'admin-home', 'adminViews/home.vue', NULL, '2022-10-17 07:00:24', 1, 0, 1);
INSERT INTO `system_menus` VALUES (16, '文章管理', 'Notebook', '/article', 'article-index', '', NULL, '2022-10-17 07:02:36', 1, 1, 1);
INSERT INTO `system_menus` VALUES (17, '文章列表', '', 'list', 'article-list', 'adminViews/article/list.vue', 16, '2022-10-17 07:03:54', 1, 0, 1);
INSERT INTO `system_menus` VALUES (18, '文章分类', '', 'class', 'article-class', 'adminViews/article/class.vue', 16, '2022-10-17 07:04:35', 1, 1, 1);
INSERT INTO `system_menus` VALUES (19, '文章标签', '', 'label', 'article-label', 'adminViews/article/label.vue', 16, '2022-10-17 07:05:39', 1, 2, 1);
INSERT INTO `system_menus` VALUES (20, '用户管理', 'User', '/user', 'users-index', '', NULL, '2022-10-17 07:07:15', 1, 2, 1);
INSERT INTO `system_menus` VALUES (21, '用户列表', '', 'list', 'user-list', 'adminViews/user/list.vue', 20, '2022-10-17 07:08:25', 1, 0, 1);
INSERT INTO `system_menus` VALUES (22, '角色设置', '', 'authority', 'user-authority', 'adminViews/user/authority.vue', 20, '2022-10-17 07:08:50', 1, 1, 1);
INSERT INTO `system_menus` VALUES (23, '网站设置', 'Setting', '/system', 'system-index', '', NULL, '2022-10-17 07:11:01', 1, 3, 1);
INSERT INTO `system_menus` VALUES (24, '菜单设置', '', 'menus', 'menus-list', 'adminViews/system/menus.vue', 23, '2022-10-17 07:11:47', 1, 0, 1);
INSERT INTO `system_menus` VALUES (25, '网站资源', '', 'resource', 'resource', '', 23, '2022-10-19 09:33:04', 1, 1, 1);
INSERT INTO `system_menus` VALUES (26, '网站信息', '', 'webInfo', 'webInfo', '', 23, '2022-10-24 14:00:55', 1, 3, 1);
INSERT INTO `system_menus` VALUES (30, '新增文章按钮', '', 'newArticleBtn', 'newArticleBtn', '', 16, '2023-02-14 14:44:00', 1, 0, 2);

-- ----------------------------
-- Table structure for system_role
-- ----------------------------
DROP TABLE IF EXISTS `system_role`;
CREATE TABLE `system_role`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增ID',
  `role_id` int(11) NULL DEFAULT NULL COMMENT '角色id',
  `menus_id` int(11) NULL DEFAULT NULL COMMENT '菜单id',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 499 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '角色绑定菜单列表' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of system_role
-- ----------------------------
INSERT INTO `system_role` VALUES (455, 7, 15);
INSERT INTO `system_role` VALUES (456, 7, 16);
INSERT INTO `system_role` VALUES (457, 7, 17);
INSERT INTO `system_role` VALUES (485, 1, 15);
INSERT INTO `system_role` VALUES (487, 1, 16);
INSERT INTO `system_role` VALUES (488, 1, 17);
INSERT INTO `system_role` VALUES (489, 1, 18);
INSERT INTO `system_role` VALUES (490, 1, 19);
INSERT INTO `system_role` VALUES (491, 1, 30);
INSERT INTO `system_role` VALUES (492, 1, 20);
INSERT INTO `system_role` VALUES (493, 1, 21);
INSERT INTO `system_role` VALUES (494, 1, 22);
INSERT INTO `system_role` VALUES (495, 1, 23);
INSERT INTO `system_role` VALUES (496, 1, 24);
INSERT INTO `system_role` VALUES (497, 1, 25);
INSERT INTO `system_role` VALUES (498, 1, 26);

-- ----------------------------
-- Table structure for system_role_info
-- ----------------------------
DROP TABLE IF EXISTS `system_role_info`;
CREATE TABLE `system_role_info`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增ID',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '角色昵称',
  `creation_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `user_id` int(11) NULL DEFAULT NULL COMMENT '创建人',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 9 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '角色列表' ROW_FORMAT = Compact;

-- ----------------------------
-- Records of system_role_info
-- ----------------------------
INSERT INTO `system_role_info` VALUES (1, '超级管理员', '2022-09-27 13:12:03', 1);
INSERT INTO `system_role_info` VALUES (7, '注册会员', '2023-01-10 13:17:55', 1);
INSERT INTO `system_role_info` VALUES (8, '游客', '2023-01-17 11:17:44', 1);

-- ----------------------------
-- Table structure for test
-- ----------------------------
DROP TABLE IF EXISTS `test`;
CREATE TABLE `test`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '姓名',
  `age` int(11) NOT NULL COMMENT '年龄',
  `num` int(11) NULL DEFAULT NULL COMMENT '数量',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of test
-- ----------------------------
INSERT INTO `test` VALUES (1, 'TH', 18, 0);
INSERT INTO `test` VALUES (2, 'dj', 20, 1);
INSERT INTO `test` VALUES (3, 'yoyo', 20, 1);

-- ----------------------------
-- Table structure for ty_user_info
-- ----------------------------
DROP TABLE IF EXISTS `ty_user_info`;
CREATE TABLE `ty_user_info`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增id',
  `user_id` text CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '腾游用户id',
  `token` varchar(1024) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '腾游用户token',
  `json` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL COMMENT '其他信息',
  `created` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '密码',
  `qq` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT 'QQ',
  `auto_close_time` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci NULL DEFAULT NULL COMMENT '自动暂停时间',
  `state` tinyint(4) NOT NULL COMMENT '启动状态',
  `err_num` int(10) NULL DEFAULT NULL COMMENT '错误次数（启动重置）',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 15 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of ty_user_info
-- ----------------------------
INSERT INTO `ty_user_info` VALUES (10, '1417396555776', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Nzc4Mjk5MzksImlhdCI6MTY3NzgyNjMzOSwianRpIjoiMTQxNzM5NjU1NTc3NiJ9.5TgWJYB56g7v1p9kYrEQMQifapOJa70OKX7nsjnerVw', '{\"user_status\":0,\"total_minutes\":119980,\"pc_vip\":0,\"expired_pc_time\":\"2024-02-21 16:06:29\",\"password\":\"\",\"head_image_url\":\"\",\"user_id\":\"1417396555776\",\"total_amount\":58,\"nick_name\":\"134****5265\",\"vpn_special_time\":0,\"pc_vip_time\":\"2022-01-20 00:00:00\",\"user_account\":\"13452045265\",\"stop_pc_time\":1,\"start_pc_time\":\"2022-03-01 00:00:00\"}', '2023-03-03 14:52:23', '123456', '522307026', '949550399059', 1, 171);
INSERT INTO `ty_user_info` VALUES (12, '6307548385280', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Nzc4MzQ0MzcsImlhdCI6MTY3NzgzMDgzNywianRpIjoiNjMwNzU0ODM4NTI4MCJ9.3RJKvalnh6jE6exvi1xRGo_UD4TRpJ_qQyA-DaqUiGc', '{\"user_status\":0,\"total_minutes\":0,\"pc_vip\":0,\"expired_pc_time\":\"2023-03-02 09:10:24\",\"password\":\"\",\"head_image_url\":\"\",\"user_id\":\"6307548385280\",\"total_amount\":0,\"nick_name\":\"\",\"vpn_special_time\":0,\"pc_vip_time\":\"2022-01-20 00:00:00\",\"user_account\":\"\",\"stop_pc_time\":1,\"start_pc_time\":\"2022-03-01 00:00:00\"}', '2023-03-03 16:07:20', '123456', '3374043477', '949550399059', 0, 0);
INSERT INTO `ty_user_info` VALUES (13, '5095316836352', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Nzc4NDAwMTcsImlhdCI6MTY3NzgzNjQxNywianRpIjoiNTA5NTMxNjgzNjM1MiJ9.b2uKecLU9vuPTuI01f4onWHa6LSk3x83KjNBJtNamWY', '{\"user_status\":0,\"total_minutes\":93398,\"pc_vip\":0,\"expired_pc_time\":\"2023-12-16 19:40:12\",\"password\":\"\",\"head_image_url\":\"\",\"user_id\":\"5095316836352\",\"total_amount\":58,\"nick_name\":\"189****0849\",\"vpn_special_time\":0,\"pc_vip_time\":\"2022-01-20 00:00:00\",\"user_account\":\"18983280849\",\"stop_pc_time\":1,\"start_pc_time\":\"2022-03-01 00:00:00\"}', '2023-03-03 17:41:54', 'dj121212', '643363809', '949550399000', 1, 169);
INSERT INTO `ty_user_info` VALUES (14, '2273088212992', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2Nzc4NDg1ODMsImlhdCI6MTY3Nzg0NDk4MywianRpIjoiMjI3MzA4ODIxMjk5MiJ9.OKC3zl5d_beTehqtXp4BGG9YmKOiVyDBrjli0TsDzyg', '{\"user_status\":0,\"total_minutes\":36519,\"pc_vip\":0,\"expired_pc_time\":\"2023-05-30 15:05:17\",\"password\":\"\",\"head_image_url\":\"\",\"user_id\":\"2273088212992\",\"total_amount\":28,\"nick_name\":\"\",\"vpn_special_time\":0,\"pc_vip_time\":\"2022-01-20 00:00:00\",\"user_account\":\"\",\"stop_pc_time\":0,\"start_pc_time\":\"2023-03-03 19:45:09\"}', '2023-03-03 20:03:19', '123', '1157418149', '949550399059', 1, 169);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(11) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'id',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '姓名',
  `age` int(11) NULL DEFAULT NULL COMMENT '年龄',
  `signature` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '签名',
  `head` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '头像',
  `account` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '帐号',
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '密码',
  `token` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '秘钥',
  `state` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '状态',
  `creation_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `last_time` datetime NULL DEFAULT NULL COMMENT '上次登录时间',
  `role_id` int(11) NULL DEFAULT NULL COMMENT '角色ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'THyo', 29, '简介简介简介简介', 'http://image.thyo.xyz/img/c568965f-8a5d-40d4-3a37-917b6d6cf2c2', '522307026', 'qq1212', 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpcCI6IjExMy4yNTEuNC4xOCIsImlzcyI6IlNPRlRJU0xBTkQuQUNDT1VOVCIsImV4cCI6MTY3ODUyMDkzNiwiaWF0IjoxNjc3OTE2MTM2LCJ1c2VySWQiOiIxIn0.e7WxDs-hE2pg6xRKWWsDkkmybkNZJG4n8I5OSrVoj5c', '1', '2022-09-01 15:18:04', '2023-03-04 15:48:56', 1);
INSERT INTO `user` VALUES (2, '游客', 20, '访问游客', 'http://image.thyo.xyz/img/49644a67-6633-a90e-76ee-0cac4571cb9e', 'guest', 'guest', 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpcCI6IjE3Mi4xNi4xMi4yNTEiLCJpc3MiOiJTT0ZUSVNMQU5ELkFDQ09VTlQiLCJleHAiOjE2NzQ1MzA3NDIsImlhdCI6MTY3MzkyNTk0MiwidXNlcklkIjoiMiJ9.DBXRdUxq2VlQaaCcUx9LIIOVbCbOYxm53p-ut3Uik_E', '', '2023-01-10 13:18:41', '2023-01-17 11:25:42', 8);
INSERT INTO `user` VALUES (7, 'yoyo', NULL, NULL, 'https://q1.qlogo.cn/g?b=qq&nk=3374043477&s=100&t=1547904810', '3374043477', '123456', NULL, '1', '2023-02-23 16:58:02', NULL, 8);
INSERT INTO `user` VALUES (10, '小黑子', NULL, NULL, 'https://q1.qlogo.cn/g?b=qq&nk=643363809&s=100&t=1547904810', '643363809', '123456', NULL, '1', '2023-02-24 15:49:48', NULL, 8);
INSERT INTO `user` VALUES (11, 'red', NULL, NULL, 'https://q1.qlogo.cn/g?b=qq&nk=643062187&s=100&t=1547904810', '643062187', '123456', NULL, '1', '2023-02-24 16:01:04', NULL, 8);
INSERT INTO `user` VALUES (12, '', NULL, '', '', '', '', NULL, '1', '2023-02-28 16:58:54', NULL, NULL);

-- ----------------------------
-- Table structure for web_config
-- ----------------------------
DROP TABLE IF EXISTS `web_config`;
CREATE TABLE `web_config`  (
  `id` int(11) NULL DEFAULT NULL COMMENT 'id',
  `titlte` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '网站标题',
  `signature` varchar(1024) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '个人简介',
  `user_img` tinytext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '个人头像',
  `brief` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '关于简介',
  `user_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '个人昵称',
  `wechat` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '微信',
  `github` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'github',
  `weibo` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '微博',
  `qq` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT 'QQ',
  `index_back` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '首页背景图',
  `archive_back` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '归档背景图',
  `aboutme_back` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '关于我背景图',
  `messageboard_back` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '留言板背景图'
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

-- ----------------------------
-- Records of web_config
-- ----------------------------
INSERT INTO `web_config` VALUES (1, 'THYO\'S BLOG', '我知你饱览过名山大川,而我只是江南一座低矮的青山,但轻舟过万重,青山依旧在\n', 'http://image.thyo.xyz/img/c2ea7202-932e-e0e8-3393-53c8e69e6aa8', '<p>关于内容编辑关于内容编辑<br></p>', 'THyo', 'THyoyoyo', 'https://github.com/THyoyoyo', 'https://www.sina.com.cn/', '522307026', 'http://image.thyo.xyz/img/e3996e4c-fa43-11f2-ce67-063b050224c2', 'http://image.thyo.xyz/img/f4239328-b716-7242-c78b-505cdcc25800', 'http://image.thyo.xyz/img/27482807-d03d-5546-c185-6a7078a20a7d', 'http://image.thyo.xyz/img/e58ea33a-1ec8-ac49-b634-3f0318bb1088');

SET FOREIGN_KEY_CHECKS = 1;
